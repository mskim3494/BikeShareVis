// Resizing a webgl canvas

/* global window, document */
import { log, isBrowser } from '../utils';
var isPage = isBrowser && typeof document !== 'undefined';
var isPageLoaded = isPage && document.readyState === 'complete';
var pageLoadPromise = isPage ? new Promise(function (resolve, reject) {
  if (isPageLoaded) {
    resolve(document);
    return;
  }

  window.onload = function () {
    isPageLoaded = true;
    resolve(document);
  };
}) : Promise.resolve({});
/**
 * Returns a promise that resolves when the page is loaded
 * at this point the DOM can be manipulated, and e.g. a new canvas can be inserted
 * @return {Promise} - resolves when the page is loaded
 */

export function getPageLoadPromise() {
  return pageLoadPromise;
}
/**
 * Create a canvas
 * @param {Number} width - set to 100%
 * @param {Number} height - set to 100%
 */

export function createCanvas(_ref) {
  var _ref$width = _ref.width,
      width = _ref$width === void 0 ? 800 : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === void 0 ? 600 : _ref$height,
      _ref$id = _ref.id,
      id = _ref$id === void 0 ? 'gl-canvas' : _ref$id,
      _ref$insert = _ref.insert,
      insert = _ref$insert === void 0 ? true : _ref$insert;
  var canvas = document.createElement('canvas');
  canvas.id = id;
  canvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : '100%';
  canvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : '100%'; // add the canvas to the body element once the page has loaded

  if (insert) {
    getPageLoadPromise().then(function (document) {
      var body = document.body;
      body.insertBefore(canvas, body.firstChild);
    });
  }

  return canvas;
}
export function getCanvas(_ref2) {
  var canvas = _ref2.canvas,
      width = _ref2.width,
      height = _ref2.height,
      _ref2$onError = _ref2.onError,
      onError = _ref2$onError === void 0 ? function () {} : _ref2$onError;
  var targetCanvas;

  if (typeof canvas === 'string') {
    if (!isPageLoaded) {
      onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
    }

    targetCanvas = document.getElementById(canvas);
  } else if (canvas) {
    targetCanvas = canvas;
  } else {
    targetCanvas = createCanvas({
      id: 'lumagl-canvas',
      width: width,
      height: height,
      onError: onError
    });
  }

  return targetCanvas;
} // Gets current size of canvas drawing buffer in actual pixels
// This is needed for the gl.viewport call

export function getDrawingBufferSize(canvas) {
  return {
    width: canvas.width,
    height: canvas.height
  };
} // Calculate the drawing buffer size that would cover current canvas size and device pixel ratio
// Intention is that every pixel in the drawing buffer will have a 1-to-1 mapping with
// actual device pixels in the hardware framebuffer, allowing us to render at the full
// resolution of the device.

export function calculateDrawingBufferSize(canvas, options) {
  var _options$useDevicePix = options.useDevicePixels,
      useDevicePixels = _options$useDevicePix === void 0 ? true : _options$useDevicePix;

  if ('useDevicePixelRatio' in options) {
    log.deprecated('useDevicePixelRatio', 'useDevicePixels')();
    useDevicePixels = options.useDevicePixels || options.useDevicePixelRatio;
  }

  var cssToDevicePixels = useDevicePixels ? window.devicePixelRatio || 1 : 1; // Lookup the size the browser is displaying the canvas in CSS pixels
  // and compute a size needed to make our drawingbuffer match it in
  // device pixels.

  return {
    width: Math.floor(canvas.clientWidth * cssToDevicePixels),
    height: Math.floor(canvas.clientHeight * cssToDevicePixels),
    devicePixelRatio: cssToDevicePixels
  };
}
/**
 * Resizes canvas in "CSS coordinates" (note these can be very different from device coords,
 * depending on devicePixelRatio/retina screens and size of drawing buffer)
 * and can be changed separately from drawing buffer size.
 * Therefore, normally `resizeDrawingBuffer` should be called after calling `resizeCanvas`.
 *
 * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
 *
 * @param {Number} width, height - new width and height of canvas in CSS coordinates
 */

export function resizeCanvas(canvas, _ref3) {
  var width = _ref3.width,
      height = _ref3.height;
  canvas.style.width = "".concat(width, "px");
  canvas.style.height = "".concat(height, "px");
}
/**
 * Resize the canvas' drawing buffer to match the canvas CSS size,
 * and by default to also consider devicePixelRatio
 * detects if anything has changed, can be called every frame
 * for best visual results, usually set to either:
 *  canvas CSS width x canvas CSS height
 *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
 *
 * NOTE: Regardless of size, the drawing buffer will always be scaled to the viewport
 * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
 *
 * @param {Number} width - new width of canvas in CSS coordinates
 * @param {Number} height - new height of canvas in CSS coordinates
 */

export function resizeDrawingBuffer(canvas, _ref4) {
  var _ref4$useDevicePixelR = _ref4.useDevicePixelRatio,
      useDevicePixelRatio = _ref4$useDevicePixelR === void 0 ? null : _ref4$useDevicePixelR,
      _ref4$useDevicePixels = _ref4.useDevicePixels,
      useDevicePixels = _ref4$useDevicePixels === void 0 ? true : _ref4$useDevicePixels;

  // Resize the render buffer of the canvas to match canvas client size
  if (useDevicePixelRatio !== null) {
    log.deprecated('useDevicePixelRatio', 'useDevicePixels')();
    useDevicePixels = useDevicePixelRatio;
  } // multiplying with dpr (Optionally can be turned off)


  var newBufferSize = calculateDrawingBufferSize(canvas, {
    useDevicePixels: useDevicePixels
  }); // Only update if the canvas size has not changed

  if (newBufferSize.width !== canvas.width || newBufferSize.height !== canvas.height) {
    // Make the canvas render buffer the same size as
    canvas.width = newBufferSize.width;
    canvas.height = newBufferSize.height; // Always reset CSS size after setting drawing buffer size
    // canvas.style.width = `${cssSize.width}px`;
    // canvas.style.height = `${cssSize.height}px`;
  }
}
//# sourceMappingURL=create-canvas.js.map