{"version":3,"sources":["../../../src/webgl-utils/create-canvas.js"],"names":["log","isBrowser","isPage","document","isPageLoaded","readyState","pageLoadPromise","Promise","resolve","reject","window","onload","getPageLoadPromise","createCanvas","width","height","id","insert","canvas","createElement","style","Number","isFinite","then","body","insertBefore","firstChild","getCanvas","onError","targetCanvas","getElementById","getDrawingBufferSize","calculateDrawingBufferSize","options","useDevicePixels","deprecated","useDevicePixelRatio","cssToDevicePixels","devicePixelRatio","Math","floor","clientWidth","clientHeight","resizeCanvas","resizeDrawingBuffer","newBufferSize"],"mappings":"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","sourcesContent":["// Resizing a webgl canvas\n\n/* global window, document */\nimport {log, isBrowser} from '../utils';\n\nconst isPage = isBrowser && typeof document !== 'undefined';\nlet isPageLoaded = isPage && document.readyState === 'complete';\n\nconst pageLoadPromise = isPage ?\n  new Promise((resolve, reject) => {\n    if (isPageLoaded) {\n      resolve(document);\n      return;\n    }\n    window.onload = () => {\n      isPageLoaded = true;\n      resolve(document);\n    };\n  }) :\n  Promise.resolve({});\n\n/**\n * Returns a promise that resolves when the page is loaded\n * at this point the DOM can be manipulated, and e.g. a new canvas can be inserted\n * @return {Promise} - resolves when the page is loaded\n */\nexport function getPageLoadPromise() {\n  return pageLoadPromise;\n}\n\n/**\n * Create a canvas\n * @param {Number} width - set to 100%\n * @param {Number} height - set to 100%\n */\nexport function createCanvas({width = 800, height = 600, id = 'gl-canvas', insert = true}) {\n  const canvas = document.createElement('canvas');\n  canvas.id = id;\n  canvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';\n  canvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';\n  // add the canvas to the body element once the page has loaded\n  if (insert) {\n    getPageLoadPromise().then(document => {\n      const body = document.body;\n      body.insertBefore(canvas, body.firstChild);\n    });\n  }\n  return canvas;\n}\n\nexport function getCanvas({canvas, width, height, onError = () => {}}) {\n  let targetCanvas;\n  if (typeof canvas === 'string') {\n    if (!isPageLoaded) {\n      onError(`createGLContext called on canvas '${canvas}' before page was loaded`);\n    }\n    targetCanvas = document.getElementById(canvas);\n  } else if (canvas) {\n    targetCanvas = canvas;\n  } else {\n    targetCanvas = createCanvas({id: 'lumagl-canvas', width, height, onError});\n  }\n\n  return targetCanvas;\n}\n\n// Gets current size of canvas drawing buffer in actual pixels\n// This is needed for the gl.viewport call\nexport function getDrawingBufferSize(canvas) {\n  return {\n    width: canvas.width,\n    height: canvas.height\n  };\n}\n\n// Calculate the drawing buffer size that would cover current canvas size and device pixel ratio\n// Intention is that every pixel in the drawing buffer will have a 1-to-1 mapping with\n// actual device pixels in the hardware framebuffer, allowing us to render at the full\n// resolution of the device.\nexport function calculateDrawingBufferSize(canvas, options) {\n  let {useDevicePixels = true} = options;\n  if ('useDevicePixelRatio' in options) {\n    log.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n    useDevicePixels = options.useDevicePixels || options.useDevicePixelRatio;\n  }\n  const cssToDevicePixels = useDevicePixels ? window.devicePixelRatio || 1 : 1;\n\n  // Lookup the size the browser is displaying the canvas in CSS pixels\n  // and compute a size needed to make our drawingbuffer match it in\n  // device pixels.\n  return {\n    width: Math.floor(canvas.clientWidth * cssToDevicePixels),\n    height: Math.floor(canvas.clientHeight * cssToDevicePixels),\n    devicePixelRatio: cssToDevicePixels\n  };\n}\n\n/**\n * Resizes canvas in \"CSS coordinates\" (note these can be very different from device coords,\n * depending on devicePixelRatio/retina screens and size of drawing buffer)\n * and can be changed separately from drawing buffer size.\n * Therefore, normally `resizeDrawingBuffer` should be called after calling `resizeCanvas`.\n *\n * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n *\n * @param {Number} width, height - new width and height of canvas in CSS coordinates\n */\nexport function resizeCanvas(canvas, {\n  width,\n  height\n}) {\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n}\n\n/**\n * Resize the canvas' drawing buffer to match the canvas CSS size,\n * and by default to also consider devicePixelRatio\n * detects if anything has changed, can be called every frame\n * for best visual results, usually set to either:\n *  canvas CSS width x canvas CSS height\n *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio\n *\n * NOTE: Regardless of size, the drawing buffer will always be scaled to the viewport\n * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n *\n * @param {Number} width - new width of canvas in CSS coordinates\n * @param {Number} height - new height of canvas in CSS coordinates\n */\nexport function resizeDrawingBuffer(canvas, {\n  useDevicePixelRatio = null, // deprecated\n  useDevicePixels = true\n}) {\n  // Resize the render buffer of the canvas to match canvas client size\n  if (useDevicePixelRatio !== null) {\n    log.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n    useDevicePixels = useDevicePixelRatio;\n  }\n  // multiplying with dpr (Optionally can be turned off)\n  const newBufferSize = calculateDrawingBufferSize(canvas, {useDevicePixels});\n  // Only update if the canvas size has not changed\n  if (newBufferSize.width !== canvas.width || newBufferSize.height !== canvas.height) {\n    // Make the canvas render buffer the same size as\n    canvas.width = newBufferSize.width;\n    canvas.height = newBufferSize.height;\n    // Always reset CSS size after setting drawing buffer size\n    // canvas.style.width = `${cssSize.width}px`;\n    // canvas.style.height = `${cssSize.height}px`;\n  }\n}\n"],"file":"create-canvas.js"}