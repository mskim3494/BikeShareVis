{"version":3,"sources":["../../../../src/core/lib/pick-layers.js"],"names":["drawPickingBuffer","getPixelRatio","log","assert","NO_PICKED_OBJECT","pickedColor","pickedLayer","pickedObjectIndex","pickObject","gl","layers","viewports","x","y","radius","layerFilter","mode","onViewportActive","pickingFBO","lastPickedInfo","useDevicePixels","pixelRatio","deviceX","Math","round","deviceY","canvas","height","deviceRadius","deviceRect","getPickingRect","deviceWidth","width","deviceHeight","pickedColors","drawAndSamplePickingBuffer","redrawReason","pickInfo","getClosestFromPickingBuffer","processPickInfo","pickVisibleObjects","deviceLeft","deviceBottom","deviceRight","deviceTop","pickInfos","getUniquesFromPickingBuffer","uniqueInfos","Map","forEach","info","color","layer","index","picked","getLayerPickingInfo","has","object","set","Array","from","values","Number","isFinite","pickableLayers","filter","isPickable","length","Uint8Array","readPixels","pixelArray","getViewportFromCoordinates","viewport","valid","max","min","affectedLayers","lastPickedObjectIndex","lastPickedLayerId","layerId","pickedLayerId","props","id","lastPickedLayer","find","unshift","baseInfo","pixel","lngLat","unproject","devicePixel","infos","Object","assign","pickingSelectedColor","autoHighlight","pickingParameters","model","getModels","updateModuleSettings","unhandledPickInfos","callLayerPickingCallbacks","handled","onClick","onHover","Error","push","minSquareDistanceToCenter","closestPixelIndex","i","row","dy","dy2","col","pickedLayerIndex","dx","d2","slice","decodePickingColor","error","uniqueColors","colorKey","join","sourceLayer","pickLayer","parentLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {drawPickingBuffer, getPixelRatio} from './draw-layers';\nimport log from '../utils/log';\nimport assert from '../utils/assert';\n\nconst NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedLayer: null,\n  pickedObjectIndex: -1\n};\n\n/* eslint-disable max-depth, max-statements */\n// Pick the closest object at the given (x,y) coordinate\nexport function pickObject(\n  gl,\n  {\n    layers,\n    viewports,\n    x,\n    y,\n    radius,\n    layerFilter,\n    mode,\n    onViewportActive,\n    pickingFBO,\n    lastPickedInfo,\n    useDevicePixels\n  }\n) {\n  // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n  const pixelRatio = getPixelRatio({useDevicePixels});\n  const deviceX = Math.round(x * pixelRatio);\n  const deviceY = Math.round(gl.canvas.height - y * pixelRatio);\n  const deviceRadius = Math.round(radius * pixelRatio);\n\n  const deviceRect = getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth: pickingFBO.width,\n    deviceHeight: pickingFBO.height\n  });\n\n  const pickedColors =\n    deviceRect &&\n    drawAndSamplePickingBuffer(gl, {\n      layers,\n      viewports,\n      onViewportActive,\n      useDevicePixels,\n      pickingFBO,\n      deviceRect,\n      layerFilter,\n      redrawReason: mode\n    });\n\n  const pickInfo =\n    (pickedColors &&\n      getClosestFromPickingBuffer(gl, {\n        pickedColors,\n        layers,\n        deviceX,\n        deviceY,\n        deviceRadius,\n        deviceRect\n      })) ||\n    NO_PICKED_OBJECT;\n\n  return processPickInfo({\n    pickInfo,\n    lastPickedInfo,\n    mode,\n    layers,\n    viewports,\n    x,\n    y,\n    deviceX,\n    deviceY,\n    pixelRatio\n  });\n}\n\n// Pick all objects within the given bounding box\nexport function pickVisibleObjects(\n  gl,\n  {\n    layers,\n    viewports,\n    x,\n    y,\n    width,\n    height,\n    mode,\n    layerFilter,\n    onViewportActive,\n    pickingFBO,\n    useDevicePixels\n  }\n) {\n  // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n  const pixelRatio = getPixelRatio({useDevicePixels});\n\n  const deviceLeft = Math.round(x * pixelRatio);\n  const deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);\n  const deviceRight = Math.round((x + width) * pixelRatio);\n  const deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);\n\n  const deviceRect = {\n    x: deviceLeft,\n    y: deviceTop,\n    width: deviceRight - deviceLeft,\n    height: deviceBottom - deviceTop\n  };\n\n  const pickedColors = drawAndSamplePickingBuffer(gl, {\n    layers,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    useDevicePixels,\n    deviceRect,\n    layerFilter,\n    redrawReason: mode\n  });\n\n  const pickInfos = getUniquesFromPickingBuffer(gl, {pickedColors, layers});\n\n  // Only return unique infos, identified by info.object\n  const uniqueInfos = new Map();\n\n  pickInfos.forEach(pickInfo => {\n    let info = {\n      color: pickInfo.pickedColor,\n      layer: null,\n      index: pickInfo.pickedObjectIndex,\n      picked: true,\n      x,\n      y,\n      width,\n      height,\n      pixelRatio\n    };\n\n    info = getLayerPickingInfo({layer: pickInfo.pickedLayer, info, mode});\n    if (!uniqueInfos.has(info.object)) {\n      uniqueInfos.set(info.object, info);\n    }\n  });\n\n  return Array.from(uniqueInfos.values());\n}\n\n// HELPER METHODS\n\n// returns pickedColor or null if no pickable layers found.\nfunction drawAndSamplePickingBuffer(\n  gl,\n  {\n    layers,\n    viewports,\n    onViewportActive,\n    useDevicePixels,\n    pickingFBO,\n    deviceRect,\n    layerFilter,\n    redrawReason\n  }\n) {\n  assert(deviceRect);\n  assert(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');\n  assert(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');\n\n  const pickableLayers = layers.filter(layer => layer.isPickable());\n  if (pickableLayers.length < 1) {\n    return null;\n  }\n\n  drawPickingBuffer(gl, {\n    layers,\n    viewports,\n    onViewportActive,\n    useDevicePixels,\n    pickingFBO,\n    deviceRect,\n    layerFilter,\n    redrawReason\n  });\n\n  // Read from an already rendered picking buffer\n  // Returns an Uint8ClampedArray of picked pixels\n  const {x, y, width, height} = deviceRect;\n  const pickedColors = new Uint8Array(width * height * 4);\n  pickingFBO.readPixels({x, y, width, height, pixelArray: pickedColors});\n  return pickedColors;\n}\n\n// Indentifies which viewport, if any corresponds to x and y\n// Returns first viewport if no match\n// TODO - need to determine which viewport we are in\n// TODO - document concept of \"primary viewport\" that matches all coords?\n// TODO - static method on Viewport class?\nfunction getViewportFromCoordinates({viewports}) {\n  const viewport = viewports[0];\n  return viewport;\n}\n\n// Calculate a picking rect centered on deviceX and deviceY and clipped to device\n// Returns null if pixel is outside of device\nfunction getPickingRect({deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight}) {\n  const valid = deviceX >= 0 && deviceY >= 0 && deviceX < deviceWidth && deviceY < deviceHeight;\n\n  // x, y out of bounds.\n  if (!valid) {\n    return null;\n  }\n\n  // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n  const x = Math.max(0, deviceX - deviceRadius);\n  const y = Math.max(0, deviceY - deviceRadius);\n  const width = Math.min(deviceWidth, deviceX + deviceRadius) - x + 1;\n  const height = Math.min(deviceHeight, deviceY + deviceRadius) - y + 1;\n\n  return {x, y, width, height};\n}\n\n// TODO - break this monster function into 3+ parts\nfunction processPickInfo({\n  pickInfo,\n  lastPickedInfo,\n  mode,\n  layers,\n  viewports,\n  x,\n  y,\n  deviceX,\n  deviceY,\n  pixelRatio\n}) {\n  const {pickedColor, pickedLayer, pickedObjectIndex} = pickInfo;\n\n  const affectedLayers = pickedLayer ? [pickedLayer] : [];\n\n  if (mode === 'hover') {\n    // only invoke onHover events if picked object has changed\n    const lastPickedObjectIndex = lastPickedInfo.index;\n    const lastPickedLayerId = lastPickedInfo.layerId;\n    const pickedLayerId = pickedLayer && pickedLayer.props.id;\n\n    // proceed only if picked object changed\n    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {\n      if (pickedLayerId !== lastPickedLayerId) {\n        // We cannot store a ref to lastPickedLayer in the context because\n        // the state of an outdated layer is no longer valid\n        // and the props may have changed\n        const lastPickedLayer = layers.find(layer => layer.props.id === lastPickedLayerId);\n        if (lastPickedLayer) {\n          // Let leave event fire before enter event\n          affectedLayers.unshift(lastPickedLayer);\n        }\n      }\n\n      // Update layer manager context\n      lastPickedInfo.layerId = pickedLayerId;\n      lastPickedInfo.index = pickedObjectIndex;\n    }\n  }\n\n  const viewport = getViewportFromCoordinates({viewports}); // TODO - add coords\n\n  const baseInfo = {\n    color: null,\n    layer: null,\n    index: -1,\n    picked: false,\n    x,\n    y,\n    pixel: [x, y],\n    lngLat: viewport.unproject([x, y]),\n    devicePixel: [deviceX, deviceY],\n    pixelRatio\n  };\n\n  // Use a Map to store all picking infos.\n  // The following two forEach loops are the result of\n  // https://github.com/uber/deck.gl/issues/443\n  // Please be very careful when changing this pattern\n  const infos = new Map();\n\n  affectedLayers.forEach(layer => {\n    let info = Object.assign({}, baseInfo);\n\n    if (layer === pickedLayer) {\n      info.color = pickedColor;\n      info.index = pickedObjectIndex;\n      info.picked = true;\n    }\n\n    info = getLayerPickingInfo({layer, info, mode});\n\n    // This guarantees that there will be only one copy of info for\n    // one composite layer\n    if (info) {\n      infos.set(info.layer.id, info);\n    }\n\n    const pickingSelectedColor =\n      layer.props.autoHighlight && pickedLayer === layer ? pickedColor : null;\n\n    const pickingParameters = {\n      pickingSelectedColor\n    };\n\n    for (const model of layer.getModels()) {\n      model.updateModuleSettings(pickingParameters);\n    }\n  });\n\n  const unhandledPickInfos = callLayerPickingCallbacks(infos, mode);\n\n  return unhandledPickInfos;\n}\n\n// Per-layer event handlers (e.g. onClick, onHover) are provided by the\n// user and out of deck.gl's control. It's very much possible that\n// the user calls React lifecycle methods in these function, such as\n// ReactComponent.setState(). React lifecycle methods sometimes induce\n// a re-render and re-generation of props of deck.gl and its layers,\n// which invalidates all layers currently passed to this very function.\n\n// Therefore, per-layer event handlers must be invoked at the end\n// of the picking operation. NO operation that relies on the states of current\n// layers should be called after this code.\nfunction callLayerPickingCallbacks(infos, mode) {\n  const unhandledPickInfos = [];\n\n  infos.forEach(info => {\n    let handled = false;\n    switch (mode) {\n      case 'click':\n        handled = info.layer.props.onClick(info);\n        break;\n      case 'hover':\n        handled = info.layer.props.onHover(info);\n        break;\n      case 'query':\n        break;\n      default:\n        throw new Error('unknown pick type');\n    }\n\n    if (!handled) {\n      unhandledPickInfos.push(info);\n    }\n  });\n\n  return unhandledPickInfos;\n}\n\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getClosestFromPickingBuffer(\n  gl,\n  {pickedColors, layers, deviceX, deviceY, deviceRadius, deviceRect}\n) {\n  assert(pickedColors);\n\n  // Traverse all pixels in picking results and find the one closest to the supplied\n  // [deviceX, deviceY]\n  const {x, y, width, height} = deviceRect;\n  let minSquareDistanceToCenter = deviceRadius * deviceRadius;\n  let closestPixelIndex = -1;\n  let i = 0;\n\n  for (let row = 0; row < height; row++) {\n    const dy = row + y - deviceY;\n    const dy2 = dy * dy;\n\n    if (dy2 > minSquareDistanceToCenter) {\n      // skip this row\n      i += 4 * width;\n    } else {\n      for (let col = 0; col < width; col++) {\n        // Decode picked layer from color\n        const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n        if (pickedLayerIndex >= 0) {\n          const dx = col + x - deviceX;\n          const d2 = dx * dx + dy2;\n\n          if (d2 <= minSquareDistanceToCenter) {\n            minSquareDistanceToCenter = d2;\n            closestPixelIndex = i;\n          }\n        }\n        i += 4;\n      }\n    }\n  }\n\n  if (closestPixelIndex >= 0) {\n    // Decode picked object index from color\n    const pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;\n    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n    const pickedLayer = layers[pickedLayerIndex];\n    if (pickedLayer) {\n      const pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);\n      return {pickedColor, pickedLayer, pickedObjectIndex};\n    }\n    log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n  }\n\n  return NO_PICKED_OBJECT;\n}\n/* eslint-enable max-depth, max-statements */\n\n/**\n * Examines a picking buffer for unique colors\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\nfunction getUniquesFromPickingBuffer(gl, {pickedColors, layers}) {\n  const uniqueColors = new Map();\n\n  // Traverse all pixels in picking results and get unique colors\n  if (pickedColors) {\n    for (let i = 0; i < pickedColors.length; i += 4) {\n      // Decode picked layer from color\n      const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        const pickedColor = pickedColors.slice(i, i + 4);\n        const colorKey = pickedColor.join(',');\n        // eslint-disable-next-line\n        if (!uniqueColors.has(colorKey)) {\n          const pickedLayer = layers[pickedLayerIndex];\n          // eslint-disable-next-line\n          if (pickedLayer) {\n            uniqueColors.set(colorKey, {\n              pickedColor,\n              pickedLayer,\n              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}\n\n// Walk up the layer composite chain to populate the info object\nfunction getLayerPickingInfo({layer, info, mode}) {\n  while (layer && info) {\n    // For a composite layer, sourceLayer will point to the sublayer\n    // where the event originates from.\n    // It provides additional context for the composite layer's\n    // getPickingInfo() method to populate the info object\n    const sourceLayer = info.layer || layer;\n    info.layer = layer;\n    // layer.pickLayer() function requires a non-null ```layer.state```\n    // object to funtion properly. So the layer refereced here\n    // must be the \"current\" layer, not an \"out-dated\" / \"invalidated\" layer\n    info = layer.pickLayer({info, mode, sourceLayer});\n    layer = layer.parentLayer;\n  }\n  return info;\n}\n"],"file":"pick-layers.js"}