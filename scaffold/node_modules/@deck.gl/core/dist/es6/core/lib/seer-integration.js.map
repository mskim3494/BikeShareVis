{"version":3,"sources":["../../../../src/core/lib/seer-integration.js"],"names":["seer","recursiveSet","obj","path","value","length","slice","overrides","Map","setPropOverrides","id","valuePath","isReady","has","set","props","get","applyPropOverrides","overs","forEach","data","layerEditListener","cb","listenFor","seerInitListener","initLayerInSeer","layer","badges","constructor","layerName","listItem","links","state","model","undefined","parent","parentLayer","updateLayerInSeer","throttle","logPayload","multiUpdate","removeLayerInSeer","deleteItem","getAttributeManager","attrs","getAttributes","push","stats","getTimeString","timerQueryEnabled","lastFrameTime","toFixed"],"mappings":"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","sourcesContent":["import seer from 'seer';\n\n/**\n * Recursively set a nested property of an object given a properties array and a value\n */\nconst recursiveSet = (obj, path, value) => {\n  if (!obj) {\n    return;\n  }\n\n  if (path.length > 1) {\n    recursiveSet(obj[path[0]], path.slice(1), value);\n  } else {\n    obj[path[0]] = value;\n  }\n};\n\nconst overrides = new Map();\n\n/**\n * Create an override on the specify layer, indexed by a valuePath array.\n * Do nothing in case Seer as not been initialized to prevent any preformance drawback.\n */\nexport const setPropOverrides = (id, valuePath, value) => {\n  if (!seer.isReady()) {\n    return;\n  }\n\n  if (!overrides.has(id)) {\n    overrides.set(id, new Map());\n  }\n\n  const props = overrides.get(id);\n  props.set(valuePath, value);\n};\n\n/**\n * Get the props overrides of a specific layer if Seer as been initialized\n * Invalidates the data to be sure new ones are always picked up.\n */\nexport const applyPropOverrides = props => {\n  if (!seer.isReady() || !props.id) {\n    return;\n  }\n\n  const overs = overrides.get(props.id);\n  if (!overs) {\n    return;\n  }\n\n  overs.forEach((value, valuePath) => {\n    recursiveSet(props, valuePath, value);\n    // Invalidate data array if we have a data override\n    if (valuePath[0] === 'data') {\n      props.data = [...props.data];\n    }\n  });\n};\n\n/**\n * Listen for deck.gl edit events\n */\nexport const layerEditListener = cb => {\n  if (!seer.isReady()) {\n    return;\n  }\n\n  seer.listenFor('deck.gl', cb);\n};\n\n/**\n * Listen for seer init events to resend data\n */\nexport const seerInitListener = cb => {\n  if (!seer.isReady()) {\n    return;\n  }\n\n  seer.listenFor('init', cb);\n};\n\nexport const initLayerInSeer = layer => {\n  if (!seer.isReady() || !layer) {\n    return;\n  }\n\n  const badges = [layer.constructor.layerName];\n\n  seer.listItem('deck.gl', layer.id, {\n    badges,\n    // TODO: Seer currently only handles single model layers\n    links: layer.state && layer.state.model ? [`luma.gl:${layer.state.model.id}`] : undefined,\n    parent: layer.parentLayer ? layer.parentLayer.id : undefined\n  });\n};\n\n/**\n * Log layer's properties to Seer\n */\nexport const updateLayerInSeer = layer => {\n  if (!seer.isReady() || seer.throttle(`deck.gl:${layer.id}`, 1e3)) {\n    return;\n  }\n\n  const data = logPayload(layer);\n  seer.multiUpdate('deck.gl', layer.id, data);\n};\n\n/**\n * On finalize of a specify layer, remove it from seer\n */\nexport const removeLayerInSeer = id => {\n  if (!seer.isReady() || !id) {\n    return;\n  }\n\n  seer.deleteItem('deck.gl', id);\n};\n\nfunction logPayload(layer) {\n  const data = [{path: 'objects.props', data: layer.props}];\n\n  const badges = [layer.constructor.layerName];\n\n  if (layer.state) {\n    if (layer.getAttributeManager()) {\n      const attrs = layer.getAttributeManager().getAttributes();\n      data.push({path: 'objects.attributes', data: attrs});\n      badges.push(layer.getAttributeManager().stats.getTimeString());\n    }\n    // TODO: Seer currently only handles single model layers\n    if (layer.state.model) {\n      layer.state.model.timerQueryEnabled = true;\n      const {lastFrameTime} = layer.state.model.stats;\n      if (lastFrameTime) {\n        badges.push(`${(lastFrameTime * 1000).toFixed(0)}Î¼s`);\n      }\n    }\n  }\n\n  data.push({path: 'badges', data: badges});\n\n  return data;\n}\n"],"file":"seer-integration.js"}