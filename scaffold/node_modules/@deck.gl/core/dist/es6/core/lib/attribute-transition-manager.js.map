{"version":3,"sources":["../../../../src/core/lib/attribute-transition-manager.js"],"names":["GL","Buffer","experimental","getShaders","getBuffers","log","assert","Transform","TRANSITION_STATE","NONE","PENDING","STARTED","ENDED","noop","AttributeTransitionManager","constructor","gl","id","attributeTransitions","needsRedraw","transform","isSupported","warn","update","attributes","opts","needsNewModel","changedTransitions","attributeName","transition","_updateAttribute","state","attribute","_createModel","sourceBuffers","destinationBuffers","elementCount","Math","min","hasAttribute","getAttributes","animatedAttributes","buffer","setCurrentTime","currentTime","uniforms","time","startTime","onStart","duration","onEnd","name","easing","run","settings","_getTransitionSettings","hasChanged","_triggerTransition","delete","Object","assign","_getCurrentAttributeState","value","type","size","oldBufferData","Float32Array","getData","dstData","accessor","Array","isArray","map","a","find","Boolean","_normalizeTransitionSettings","Number","isFinite","t","onInterrupt","transitionSettings","needsNewBuffer","bufferSize","length","fromState","toState","data","instanced","usage","DYNAMIC_COPY"],"mappings":"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","sourcesContent":["import {GL, Buffer, experimental} from 'luma.gl';\nimport {getShaders, getBuffers} from './attribute-transition-utils';\nimport log from '../utils/log';\nimport assert from '../utils/assert';\n\nconst {Transform} = experimental;\n\nconst TRANSITION_STATE = {\n  NONE: 0,\n  PENDING: 1,\n  STARTED: 2,\n  ENDED: 3\n};\n\nconst noop = () => {};\n\nexport default class AttributeTransitionManager {\n  constructor(gl, {id}) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributeTransitions = {};\n    this.needsRedraw = false;\n    this.transform = null;\n\n    if (Transform.isSupported(gl)) {\n      this.isSupported = true;\n    } else {\n      log.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();\n    }\n  }\n\n  /* Public methods */\n\n  // Called when attribute manager updates\n  // Check the latest attributes for updates.\n  update(attributes, opts = {}) {\n    this.opts = opts;\n\n    if (!this.isSupported) {\n      return;\n    }\n\n    let needsNewModel = false;\n    const {attributeTransitions} = this;\n    const changedTransitions = {};\n\n    for (const attributeName in attributes) {\n      const transition = this._updateAttribute(attributeName, attributes[attributeName].state);\n\n      if (transition) {\n        if (!attributeTransitions[attributeName]) {\n          // New animated attribute is added\n          attributeTransitions[attributeName] = transition;\n          needsNewModel = true;\n        }\n        changedTransitions[attributeName] = transition;\n      }\n    }\n\n    for (const attributeName in attributeTransitions) {\n      const attribute = attributes[attributeName];\n\n      if (!attribute || !attribute.state.transition) {\n        // Animated attribute has been removed\n        delete attributeTransitions[attributeName];\n        needsNewModel = true;\n      }\n    }\n\n    if (needsNewModel) {\n      this._createModel();\n    } else if (this.transform) {\n      const {sourceBuffers, destinationBuffers, elementCount} = getBuffers(changedTransitions);\n      this.transform.elementCount = Math.min(this.transform.elementCount, elementCount);\n      this.transform.update({\n        sourceBuffers,\n        destinationBuffers\n      });\n    }\n  }\n\n  // Returns `true` if attribute is transition-enabled\n  hasAttribute(attributeName) {\n    return attributeName in this.attributeTransitions;\n  }\n\n  // Get all the animated attributes\n  getAttributes() {\n    const animatedAttributes = {};\n\n    for (const attributeName in this.attributeTransitions) {\n      const transition = this.attributeTransitions[attributeName];\n\n      if (transition.buffer) {\n        animatedAttributes[attributeName] = transition.buffer;\n      }\n    }\n\n    return animatedAttributes;\n  }\n\n  /* eslint-disable max-statements */\n  // Called every render cycle, run transform feedback\n  // Returns `true` if anything changes\n  setCurrentTime(currentTime) {\n    if (!this.transform) {\n      return false;\n    }\n\n    const uniforms = {};\n\n    let needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n\n    for (const attributeName in this.attributeTransitions) {\n      const transition = this.attributeTransitions[attributeName];\n\n      let time = 1;\n      if (transition.state === TRANSITION_STATE.PENDING) {\n        transition.startTime = currentTime;\n        transition.state = TRANSITION_STATE.STARTED;\n        transition.onStart(transition);\n      }\n\n      if (transition.state === TRANSITION_STATE.STARTED) {\n        time = (currentTime - transition.startTime) / transition.duration;\n        if (time >= 1) {\n          time = 1;\n          transition.state = TRANSITION_STATE.ENDED;\n          transition.onEnd(transition);\n        }\n        needsRedraw = true;\n      }\n      uniforms[`${transition.name}Time`] = transition.easing(time);\n    }\n\n    if (needsRedraw) {\n      this.transform.run({uniforms});\n    }\n\n    return needsRedraw;\n  }\n  /* eslint-enable max-statements */\n\n  /* Private methods */\n\n  // Check an attributes for updates\n  // Returns a transition object if a new transition is triggered.\n  _updateAttribute(attributeName, attribute) {\n    const settings = this._getTransitionSettings(attribute);\n\n    if (settings) {\n      let hasChanged;\n      let transition = this.attributeTransitions[attributeName];\n      if (transition) {\n        hasChanged = attribute.needsRedraw;\n      } else {\n        // New animated attributes have been added\n        transition = {name: attributeName, attribute};\n        hasChanged = true;\n      }\n\n      if (hasChanged) {\n        this._triggerTransition(transition, settings);\n        return transition;\n      }\n    }\n\n    return null;\n  }\n\n  // Create a model for the transform feedback\n  _createModel() {\n    if (this.transform) {\n      this.transform.delete();\n    }\n    this.transform = new Transform(\n      this.gl,\n      Object.assign(\n        {},\n        getBuffers(this.attributeTransitions),\n        getShaders(this.attributeTransitions)\n      )\n    );\n  }\n\n  // get current values of an attribute, clipped/padded to the size of the new buffer\n  _getCurrentAttributeState(transition) {\n    const {attribute, buffer} = transition;\n    const {value, type, size} = attribute;\n\n    if (buffer) {\n      // If new buffer is bigger than old buffer, back fill with destination values\n      let oldBufferData = new Float32Array(value);\n      buffer.getData({dstData: oldBufferData});\n      // Hack/Xiaoji: WebGL2 throws error if TransformFeedback does not render to\n      // a buffer of type Float32Array.\n      // Therefore we need to read data as a Float32Array then re-cast to attribute type\n      if (!(value instanceof Float32Array)) {\n        oldBufferData = new value.constructor(oldBufferData);\n      }\n      return {size, type, value: oldBufferData};\n    }\n    return {size, type, value};\n  }\n\n  // Returns transition settings object if transition is enabled, otherwise `null`\n  _getTransitionSettings(attribute) {\n    const {opts} = this;\n    const {transition, accessor} = attribute;\n\n    if (!transition) {\n      return null;\n    }\n\n    return Array.isArray(accessor) ? accessor.map(a => opts[a]).find(Boolean) : opts[accessor];\n  }\n\n  // Normalizes transition settings object, merge with default settings\n  _normalizeTransitionSettings(settings) {\n    // Shorthand: use duration instead of parameter object\n    if (Number.isFinite(settings)) {\n      settings = {duration: settings};\n    }\n\n    // Check if settings is valid\n    assert(settings && settings.duration > 0);\n\n    return {\n      duration: settings.duration,\n      easing: settings.easing || (t => t),\n      onStart: settings.onStart || noop,\n      onEnd: settings.onEnd || noop,\n      onInterrupt: settings.onInterrupt || noop\n    };\n  }\n\n  // Start a new transition using the current settings\n  // Updates transition state and from/to buffer\n  _triggerTransition(transition, settings) {\n    this.needsRedraw = true;\n\n    const {attribute, buffer} = transition;\n    const {value, size} = attribute;\n\n    const transitionSettings = this._normalizeTransitionSettings(settings);\n\n    const needsNewBuffer = !buffer || transition.bufferSize < value.length;\n\n    // Attribute descriptor to transition from\n    // _getCurrentAttributeState must be called before the current buffer is deleted\n    const fromState = this._getCurrentAttributeState(transition);\n\n    // Attribute descriptor to transition to\n    // Pre-converting to buffer to reuse in the case where no transition is needed\n    const toState = new Buffer(this.gl, {size, data: value});\n\n    if (needsNewBuffer) {\n      if (buffer) {\n        buffer.delete();\n      }\n\n      transition.buffer = new Buffer(this.gl, {\n        size,\n        instanced: attribute.instanced,\n        // WebGL2 throws error if `value` is not cast to Float32Array:\n        // `transformfeedback buffers : buffer or buffer range not large enough`\n        data: new Float32Array(value.length),\n        usage: GL.DYNAMIC_COPY\n      });\n      transition.bufferSize = value.length;\n    }\n\n    Object.assign(transition, transitionSettings);\n    if (transition.fromState) {\n      transition.fromState.delete();\n    }\n    transition.fromState = new Buffer(\n      this.gl,\n      Object.assign({}, fromState, {\n        data: fromState.value\n      })\n    );\n    if (transition.toState) {\n      transition.toState.delete();\n    }\n    transition.toState = toState;\n\n    // Reset transition state\n    if (transition.state === TRANSITION_STATE.STARTED) {\n      transition.onInterrupt(transition);\n    }\n    transition.state = TRANSITION_STATE.PENDING;\n  }\n}\n"],"file":"attribute-transition-manager.js"}