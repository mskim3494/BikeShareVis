{"version":3,"sources":["../../../../src/core/lib/attribute-manager.js"],"names":["Attribute","log","assert","AttributeTransitionManager","LOG_START_END_PRIORITY","LOG_DETAIL_PRIORITY","noop","logFunctions","savedMessages","timeStart","onLog","level","message","onUpdateStart","numInstances","Date","onUpdate","push","onUpdateEnd","id","timeMs","Math","round","time","group","collapsed","groupEnd","AttributeManager","setDefaultLogFunctions","undefined","constructor","gl","stats","attributes","updateTriggers","accessors","needsRedraw","userData","attributeTransitionManager","Object","seal","finalize","getNeedsRedraw","clearRedrawFlags","redraw","setNeedsRedraw","add","updaters","_add","addInstanced","instanced","remove","attributeNameArray","i","length","name","invalidate","triggerName","invalidatedAttributes","_invalidateTrigger","invalidateAll","attributeName","setNeedsUpdate","update","data","transitions","props","buffers","context","ignoreUnknownAttributes","_checkExternalBuffers","_setExternalBuffers","_checkIfBuffersNeedUpdating","_allocateBuffers","_updateBuffers","timeEnd","updateTransition","transitionUpdated","setCurrentTime","now","getAttributes","attribute","getBuffer","getChangedAttributes","transition","clearChangedFlags","changedAttributes","hasAttribute","getAccessors","extraProps","removed","newAttributes","isGeneric","isIndexed","elements","size","value","assign","_mapUpdateTriggersToAttributes","triggers","accessor","state","Array","isArray","forEach","accessorName","keys","join","warn","bufferMap","buffer","setExternalBuffer","Error","needsUpdate","setNumInstances","allocate","updated"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\nimport Attribute from './attribute';\nimport log from '../utils/log';\nimport assert from '../utils/assert';\n\nimport AttributeTransitionManager from './attribute-transition-manager';\n\nconst LOG_START_END_PRIORITY = 2;\nconst LOG_DETAIL_PRIORITY = 3;\n\nfunction noop() {}\n\n// Default loggers\nconst logFunctions = {\n  savedMessages: null,\n  timeStart: null,\n  onLog: ({level, message}) => {\n    log.log(level, message)();\n  },\n  onUpdateStart: ({level, numInstances}) => {\n    logFunctions.savedMessages = [];\n    logFunctions.timeStart = new Date();\n  },\n  onUpdate: ({level, message}) => {\n    if (logFunctions.savedMessages) {\n      logFunctions.savedMessages.push(message);\n    }\n  },\n  onUpdateEnd: ({level, id, numInstances}) => {\n    const timeMs = Math.round(new Date() - logFunctions.timeStart);\n    const time = `${timeMs}ms`;\n    log.group(level, `Updated attributes for ${numInstances} instances in ${id} in ${time}`, {\n      collapsed: true\n    })();\n    for (const message of logFunctions.savedMessages) {\n      log.log(level, message)();\n    }\n    log.groupEnd(level, `Updated attributes for ${numInstances} instances in ${id} in ${time}`)();\n    logFunctions.savedMessages = null;\n  }\n};\n\nexport default class AttributeManager {\n  /**\n   * Sets log functions to help trace or time attribute updates.\n   * Default logging uses deck logger.\n   *\n   * `onLog` is called for each attribute.\n   *\n   * To enable detailed control of timming and e.g. hierarchical logging,\n   * hooks are also provided for update start and end.\n   *\n   * @param {Object} [opts]\n   * @param {String} [onLog=] - called to print\n   * @param {String} [onUpdateStart=] - called before update() starts\n   * @param {String} [onUpdateEnd=] - called after update() ends\n   */\n  static setDefaultLogFunctions({onLog, onUpdateStart, onUpdate, onUpdateEnd} = {}) {\n    if (onLog !== undefined) {\n      logFunctions.onLog = onLog || noop;\n    }\n    if (onUpdateStart !== undefined) {\n      logFunctions.onUpdateStart = onUpdateStart || noop;\n    }\n    if (onUpdate !== undefined) {\n      logFunctions.onUpdate = onUpdate || noop;\n    }\n    if (onUpdateEnd !== undefined) {\n      logFunctions.onUpdateEnd = onUpdateEnd || noop;\n    }\n  }\n\n  /**\n   * @classdesc\n   * Automated attribute generation and management. Suitable when a set of\n   * vertex shader attributes are generated by iteration over a data array,\n   * and updates to these attributes are needed either when the data itself\n   * changes, or when other data relevant to the calculations change.\n   *\n   * - First the application registers descriptions of its dynamic vertex\n   *   attributes using AttributeManager.add().\n   * - Then, when any change that affects attributes is detected by the\n   *   application, the app will call AttributeManager.invalidate().\n   * - Finally before it renders, it calls AttributeManager.update() to\n   *   ensure that attributes are automatically rebuilt if anything has been\n   *   invalidated.\n   *\n   * The application provided update functions describe how attributes\n   * should be updated from a data array and are expected to traverse\n   * that data array (or iterable) and fill in the attribute's typed array.\n   *\n   * Note that the attribute manager intentionally does not do advanced\n   * change detection, but instead makes it easy to build such detection\n   * by offering the ability to \"invalidate\" each attribute separately.\n   */\n  constructor(gl, {id = 'attribute-manager', stats} = {}) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributes = {};\n\n    this.updateTriggers = {};\n    this.accessors = {};\n    this.needsRedraw = true;\n\n    this.userData = {};\n    this.stats = stats;\n\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: `${id}-transitions`\n    });\n\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n\n  finalize() {\n    // TODO - call attribute.finalize()\n  }\n\n  // Returns the redraw flag, optionally clearing it.\n  // Redraw flag will be set if any attributes attributes changed since\n  // flag was last cleared.\n  //\n  // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n  // @return {false|String} - reason a redraw is needed.\n  getNeedsRedraw({clearRedrawFlags = false} = {}) {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !clearRedrawFlags;\n    return redraw && this.id;\n  }\n\n  // Sets the redraw flag.\n  // @param {Boolean} redraw=true\n  // @return {AttributeManager} - for chaining\n  setNeedsRedraw(redraw = true) {\n    this.needsRedraw = true;\n    return this;\n  }\n\n  // Adds attributes\n  add(attributes, updaters = {}) {\n    this._add(attributes, updaters);\n  }\n\n  // Adds attributes\n  addInstanced(attributes, updaters = {}) {\n    this._add(attributes, updaters, {instanced: 1});\n  }\n\n  /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray) {\n    for (let i = 0; i < attributeNameArray.length; i++) {\n      const name = attributeNameArray[i];\n      if (this.attributes[name] !== undefined) {\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  // Marks an attribute for update\n  invalidate(triggerName) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName);\n    // For performance tuning\n    logFunctions.onLog({\n      level: LOG_DETAIL_PRIORITY,\n      message: `invalidated attributes ${invalidatedAttributes} (${triggerName}) for ${this.id}`\n    });\n  }\n\n  invalidateAll() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate();\n    }\n    // For performance tuning\n    logFunctions.onLog({\n      level: LOG_DETAIL_PRIORITY,\n      message: `invalidated all attributes for ${this.id}`\n    });\n  }\n\n  // Ensure all attribute buffers are updated from props or data.\n  update({\n    data,\n    numInstances,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {},\n    ignoreUnknownAttributes = false\n  } = {}) {\n    // First apply any application provided buffers\n    this._checkExternalBuffers({buffers, ignoreUnknownAttributes});\n    this._setExternalBuffers(buffers);\n\n    // Only initiate alloc/update (and logging) if actually needed\n    if (this._checkIfBuffersNeedUpdating({numInstances})) {\n      logFunctions.onUpdateStart({level: LOG_START_END_PRIORITY, id: this.id, numInstances});\n      if (this.stats) {\n        this.stats.timeStart('attribute updates', this.id);\n      }\n      this._allocateBuffers({numInstances, data, props, context});\n      this._updateBuffers({numInstances, data, props, context});\n      if (this.stats) {\n        this.stats.timeEnd('attribute updates', this.id);\n      }\n      logFunctions.onUpdateEnd({level: LOG_START_END_PRIORITY, id: this.id, numInstances});\n    }\n\n    this.attributeTransitionManager.update(this.attributes, transitions);\n  }\n\n  // Update attribute transition to the current timestamp\n  // Returns `true` if any transition is in progress\n  updateTransition() {\n    const {attributeTransitionManager} = this;\n    const transitionUpdated = attributeTransitionManager.setCurrentTime(Date.now());\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes() {\n    const attributes = {};\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attributes[attributeName] = attribute.getBuffer();\n    }\n    return attributes;\n  }\n\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuggers need to be updated\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes({transition = false, clearChangedFlags = false}) {\n    const {attributes, attributeTransitionManager} = this;\n\n    if (transition) {\n      return attributeTransitionManager.getAttributes();\n    }\n\n    const changedAttributes = {};\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw({clearChangedFlags: true})) {\n        // Only return non-transition attributes\n        if (!attributeTransitionManager.hasAttribute(attributeName)) {\n          changedAttributes[attributeName] = attribute.getBuffer();\n        }\n      }\n    }\n    return changedAttributes;\n  }\n\n  // PROTECTED METHODS - Only to be used by collaborating classes, not by apps\n\n  // Returns object containing all accessors as keys, with non-null values\n  // @return {Object} - accessors object\n  getAccessors() {\n    return this.updateTriggers;\n  }\n\n  // PRIVATE METHODS\n\n  // Used to register an attribute\n  _add(attributes, updaters, extraProps = {}) {\n    if (updaters) {\n      log.removed('AttributeManager.add({updaters}) - updater map no longer supported');\n    }\n\n    const newAttributes = {};\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      newAttributes[attributeName] = new Attribute({\n        id: attributeName,\n        // Metadata\n        attribute,\n        // Luma fields\n        isGeneric: attribute.isGeneric || false,\n        isIndexed: attribute.isIndexed || attribute.elements,\n        size: (attribute.elements && 1) || attribute.size,\n        value: attribute.value || null,\n        instanced: attribute.instanced || extraProps.instanced\n      });\n    }\n\n    Object.assign(this.attributes, newAttributes);\n\n    this._mapUpdateTriggersToAttributes();\n  }\n  /* eslint-enable max-statements */\n\n  // build updateTrigger name to attribute name mapping\n  _mapUpdateTriggersToAttributes() {\n    const triggers = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      let {accessor} = attribute.state;\n\n      // Backards compatibility: allow attribute name to be used as update trigger key\n      triggers[attributeName] = [attributeName];\n\n      // use accessor name as update trigger key\n      if (typeof accessor === 'string') {\n        accessor = [accessor];\n      }\n      if (Array.isArray(accessor)) {\n        accessor.forEach(accessorName => {\n          if (!triggers[accessorName]) {\n            triggers[accessorName] = [];\n          }\n          triggers[accessorName].push(attributeName);\n        });\n      }\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  _invalidateTrigger(triggerName) {\n    const {attributes, updateTriggers} = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n\n    if (!invalidatedAttributes) {\n      let message = `invalidating non-existent trigger ${triggerName} for ${this.id}\\n`;\n      message += `Valid triggers: ${Object.keys(attributes).join(', ')}`;\n      log.warn(message, invalidatedAttributes)();\n    } else {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate();\n        }\n      });\n    }\n    return invalidatedAttributes;\n  }\n\n  // Set the buffers for the supplied attributes\n  // Update attribute buffers from any attributes in props\n  // Detach any previously set buffers, marking all\n  // Attributes for auto allocation\n  /* eslint-disable max-statements, max-depth */\n  _setExternalBuffers(bufferMap) {\n    // Copy the refs of any supplied buffers in the props\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n\n      const buffer = bufferMap[attributeName];\n      attribute.setExternalBuffer(buffer, this.numInstances);\n      this.needsRedraw |= attribute.needsRedraw();\n    }\n  }\n\n  // Checks that any attribute buffers in props are valid\n  // Note: This is just to help app catch mistakes\n  _checkExternalBuffers({buffers = {}, ignoreUnknownAttributes = false} = {}) {\n    const {attributes} = this;\n    for (const attributeName in buffers) {\n      const attribute = attributes[attributeName];\n      if (!attribute && !ignoreUnknownAttributes) {\n        throw new Error(`Unknown attribute prop ${attributeName}`);\n      }\n    }\n  }\n\n  /* Checks that typed arrays for attributes are big enough\n   * sets alloc flag if not\n   * @return {Boolean} whether any updates are needed\n   */\n  _checkIfBuffersNeedUpdating({numInstances}) {\n    assert(numInstances !== undefined, 'numInstances not defined');\n\n    // Track whether any allocations or updates are needed\n    let needsUpdate = false;\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.setNumInstances(numInstances);\n      needsUpdate = needsUpdate || attribute.needsUpdate();\n    }\n\n    return needsUpdate;\n  }\n\n  // Calls update on any buffers that need update\n  // TODO? - If app supplied all attributes, no need to iterate over data\n  //\n  // @param {Object} data - data (iterable object)\n  // @param {Object} numInstances - count of data\n  // @param {Object} props - passed to updaters\n  // @param {Object} context - Used as \"this\" context for updaters\n  _allocateBuffers({numInstances, data, props, context}) {\n    const {attributes} = this;\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      if (attribute.allocate(numInstances)) {\n        logFunctions.onUpdate({\n          level: LOG_DETAIL_PRIORITY,\n          message: `${attributeName} allocated ${numInstances}`,\n          id: this.id\n        });\n      }\n    }\n  }\n\n  // Calls update on any buffers that need update\n  _updateBuffers({numInstances, data, props, context}) {\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n\n      // Call updater function if needed\n      const timeStart = Date.now();\n\n      const updated = attribute.update({numInstances, data, props, context});\n      if (updated) {\n        this.needsRedraw = true;\n\n        const timeMs = Math.round(Date.now() - timeStart);\n        logFunctions.onUpdate({\n          level: LOG_DETAIL_PRIORITY,\n          message: `${attributeName} updated ${numInstances} in ${timeMs}ms`\n        });\n      }\n    }\n  }\n}\n"],"file":"attribute-manager.js"}