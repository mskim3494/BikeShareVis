{"version":3,"sources":["../../../../src/core/utils/math-utils.js"],"names":["vec4_multiply","vec4_transformMat4","assert","Matrix4","radians","transformVector","matrix","vector","result","scale","createMat4","extractCameraVectors","viewMatrix","viewMatrixInverse","eye","direction","up","mod","value","divisor","Number","isFinite","modulus","lerp","start","end","step","Array","isArray","map","element","index","createOrthographicMatrix","fovY","aspect","focalDistance","near","far","halfY","top","Math","tan","right","ortho","left","bottom","getProjectionParameters","width","height","altitude","pitch","farZMultiplier","pitchRadians","halfFov","atan","topHalfSurfaceDistance","sin","PI","farZ","cos","fov"],"mappings":"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","sourcesContent":["// Extensions to math.gl library. Intended to be folded back.\n\nimport vec4_multiply from 'gl-vec4/multiply';\nimport vec4_transformMat4 from 'gl-vec4/transformMat4';\nimport assert from '../utils/assert';\nimport {Matrix4, radians} from 'math.gl';\n\nexport function transformVector(matrix, vector) {\n  // Handle non-invertible matrix\n  if (!matrix) {\n    return null;\n  }\n  const result = vec4_transformMat4([0, 0, 0, 0], vector, matrix);\n  const scale = 1 / result[3];\n  vec4_multiply(result, result, [scale, scale, scale, scale]);\n  return result;\n}\n\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\nexport function createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\n// Extract camera vectors (move to math library?)\nexport function extractCameraVectors({viewMatrix, viewMatrixInverse}) {\n  // Read the translation from the inverse view matrix\n  return {\n    eye: [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]],\n    direction: [viewMatrix[2], viewMatrix[6], viewMatrix[10]],\n    up: [viewMatrix[1], viewMatrix[5], viewMatrix[9]]\n  };\n}\n\nexport function mod(value, divisor) {\n  assert(Number.isFinite(value) && Number.isFinite(divisor));\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\n\nexport function lerp(start, end, step) {\n  if (Array.isArray(start)) {\n    return start.map((element, index) => {\n      return lerp(element, end[index], step);\n    });\n  }\n  return step * end + (1 - step) * start;\n}\n\n// TODO - this method is being added to math.gl, remove when published\nexport function createOrthographicMatrix({fovY, aspect, focalDistance, near, far}) {\n  const halfY = fovY / 2;\n  const top = focalDistance * Math.tan(halfY); // focus_plane is the distance from the camera\n  const right = top * aspect;\n\n  return new Matrix4().ortho({\n    left: -right,\n    right,\n    bottom: -top,\n    top,\n    near,\n    far\n  });\n}\n\n// TODO - this function is being added to viewport-mercator-project, remove when published\n// PROJECTION MATRIX PARAMETERS\n// This is a \"Mapbox\" projection matrix - matches mapbox exactly if farZMultiplier === 1\n// Variable fov (in radians)\nexport function getProjectionParameters({\n  width,\n  height,\n  altitude = 1.5,\n  pitch = 0,\n  farZMultiplier = 1\n}) {\n  // Find the distance from the center point to the center top\n  // in altitude units using law of sines.\n  const pitchRadians = radians(pitch);\n  const halfFov = Math.atan(0.5 / altitude);\n  const topHalfSurfaceDistance =\n    Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);\n\n  // Calculate z value of the farthest fragment that should be rendered.\n  const farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;\n\n  return {\n    fov: 2 * Math.atan(height / 2 / altitude),\n    aspect: width / height,\n    focalDistance: altitude,\n    near: 0.1,\n    far: farZ * farZMultiplier\n  };\n}\n"],"file":"math-utils.js"}