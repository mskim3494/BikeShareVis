function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import OrbitViewport from '../viewports/orbit-viewport';
import OrbitState from '../controllers/orbit-state';
import ViewportControls from '../controllers/viewport-controls';
import { EventManager } from 'mjolnir.js';
var PREFIX = '-webkit-';
var CURSOR = {
  GRABBING: "".concat(PREFIX, "grabbing"),
  GRAB: "".concat(PREFIX, "grab"),
  POINTER: 'pointer'
};

var getDefaultCursor = function getDefaultCursor(_ref) {
  var isDragging = _ref.isDragging;
  return isDragging ? CURSOR.GRABBING : CURSOR.GRAB;
};

function getPropTypes(PropTypes) {
  return {
    /* Viewport properties */
    lookAt: PropTypes.arrayOf(PropTypes.number),
    // target position
    distance: PropTypes.number,
    // distance from camera to the target
    rotationX: PropTypes.number,
    // rotation around X axis
    rotationY: PropTypes.number,
    // rotation around Y axis
    translationX: PropTypes.number,
    // translation x in screen space
    translationY: PropTypes.number,
    // translation y in screen space
    zoom: PropTypes.number,
    // scale in screen space
    minZoom: PropTypes.number,
    maxZoom: PropTypes.number,
    fov: PropTypes.number,
    // field of view
    near: PropTypes.number,
    far: PropTypes.number,
    width: PropTypes.number.isRequired,
    // viewport width in pixels
    height: PropTypes.number.isRequired,
    // viewport height in pixels

    /* Model properties */
    bounds: PropTypes.object,
    // bounds in the shape of {minX, minY, minZ, maxX, maxY, maxZ}

    /* Callbacks */
    onViewportChange: PropTypes.func.isRequired,

    /** Accessor that returns a cursor style to show interactive state */
    getCursor: PropTypes.func,

    /* Controls */
    orbitControls: PropTypes.object
  };
}

var defaultProps = {
  lookAt: [0, 0, 0],
  rotationX: 0,
  rotationY: 0,
  translationX: 0,
  translationY: 0,
  distance: 10,
  zoom: 1,
  minZoom: 0,
  maxZoom: Infinity,
  fov: 50,
  near: 1,
  far: 1000,
  getCursor: getDefaultCursor
};
/*
 * Maps mouse interaction to a deck.gl Viewport
 */

var OrbitController =
/*#__PURE__*/
function () {
  _createClass(OrbitController, null, [{
    key: "getViewport",
    // Returns a deck.gl Viewport instance, to be used with the DeckGL component
    value: function getViewport(viewport) {
      return new OrbitViewport(viewport);
    }
  }]);

  function OrbitController(props) {
    _classCallCheck(this, OrbitController);

    props = Object.assign({}, defaultProps, props);
    this.props = props;
    this.state = {
      // Whether the cursor is down
      isDragging: false
    };
    this.canvas = props.canvas;
    var eventManager = new EventManager(this.canvas);
    this._eventManager = eventManager;
    this._controls = props.orbitControls || new ViewportControls(OrbitState);

    this._controls.setOptions(Object.assign({}, this.props, {
      onStateChange: this._onInteractiveStateChange.bind(this),
      eventManager: eventManager
    }));
  }

  _createClass(OrbitController, [{
    key: "setProps",
    value: function setProps(props) {
      props = Object.assign({}, this.props, props);
      this.props = props;

      this._controls.setOptions(props);
    }
  }, {
    key: "finalize",
    value: function finalize() {
      this._eventManager.destroy();
    }
  }, {
    key: "_onInteractiveStateChange",
    value: function _onInteractiveStateChange(_ref2) {
      var _ref2$isDragging = _ref2.isDragging,
          isDragging = _ref2$isDragging === void 0 ? false : _ref2$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.state.isDragging = isDragging;
        var getCursor = this.props.getCursor;
        this.canvas.style.cursor = getCursor(this.state);
      }
    }
  }]);

  return OrbitController;
}();

export { OrbitController as default };
OrbitController.displayName = 'OrbitController';
OrbitController.defaultProps = defaultProps;
OrbitController.getPropTypes = getPropTypes;
//# sourceMappingURL=orbit-controller.js.map