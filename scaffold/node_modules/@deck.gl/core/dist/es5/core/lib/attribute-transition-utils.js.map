{"version":3,"sources":["../../../../src/core/lib/attribute-transition-utils.js"],"names":["ATTRIBUTE_MAPPING","getShaders","transitions","varyings","attributeDeclarations","uniformsDeclarations","varyingDeclarations","calculations","attributeName","transition","attributeType","attribute","size","bufferIndex","length","push","vs","join","fs","getBuffers","sourceBuffers","destinationBuffers","elementCount","fromState","toState","buffer","count","value","Math","min"],"mappings":";;;;;;;AAAA,IAAMA,oBAAoB;AACxB,KAAG,OADqB;AAExB,KAAG,MAFqB;AAGxB,KAAG,MAHqB;AAIxB,KAAG;AAJqB,CAA1B;;AAOO,SAASC,UAAT,CAAoBC,WAApB,EAAiC;AACtC;AACA,MAAMC,WAAW,EAAjB;AACA,MAAMC,wBAAwB,EAA9B;AACA,MAAMC,uBAAuB,EAA7B;AACA,MAAMC,sBAAsB,EAA5B;AACA,MAAMC,eAAe,EAArB;;AAEA,OAAK,IAAMC,aAAX,IAA4BN,WAA5B,EAAyC;AACvC,QAAMO,aAAaP,YAAYM,aAAZ,CAAnB;AACA,QAAME,gBAAgBV,kBAAkBS,WAAWE,SAAX,CAAqBC,IAAvC,CAAtB;;AAEA,QAAIF,aAAJ,EAAmB;AACjBD,iBAAWI,WAAX,GAAyBV,SAASW,MAAlC;AACAX,eAASY,IAAT,CAAcP,aAAd;AAEAJ,4BAAsBW,IAAtB,qBAAwCL,aAAxC,cAAyDF,aAAzD;AACAJ,4BAAsBW,IAAtB,qBAAwCL,aAAxC,cAAyDF,aAAzD;AACAH,2BAAqBU,IAArB,yBAA2CP,aAA3C;AACAF,0BAAoBS,IAApB,mBAAoCL,aAApC,cAAqDF,aAArD;AACAD,mBAAaQ,IAAb,WAAqBP,aAArB,oBAA4CA,aAA5C,mBAAkEA,aAAlE,0BACIA,aADJ;AAED;AACF;;AAED,MAAMQ,6DAENZ,sBAAsBa,IAAtB,CAA2B,IAA3B,CAFM,eAGNZ,qBAAqBY,IAArB,CAA0B,IAA1B,CAHM,eAINX,oBAAoBW,IAApB,CAAyB,IAAzB,CAJM,sCAOJV,aAAaU,IAAb,CAAkB,IAAlB,CAPI,sCAAN;AAYA,MAAMC,+GAONZ,oBAAoBW,IAApB,CAAyB,IAAzB,CAPM,4DAAN;AAaA,SAAO;AAACD,UAAD;AAAKE,UAAL;AAASf;AAAT,GAAP;AACD;;AAEM,SAASgB,UAAT,CAAoBjB,WAApB,EAAiC;AACtC,MAAMkB,gBAAgB,EAAtB;AACA,MAAMC,qBAAqB,EAA3B;AACA,MAAIC,eAAe,IAAnB;;AACA,OAAK,IAAMd,aAAX,IAA4BN,WAA5B,EAAyC;AAAA,gCACSA,YAAYM,aAAZ,CADT;AAAA,QAChCe,SADgC,yBAChCA,SADgC;AAAA,QACrBC,OADqB,yBACrBA,OADqB;AAAA,QACZC,MADY,yBACZA,MADY;AAAA,QACJd,SADI,yBACJA,SADI;AAEvC,QAAMe,QAAQf,UAAUgB,KAAV,CAAgBb,MAAhB,GAAyBH,UAAUC,IAAjD;AACAQ,4BAAiBZ,aAAjB,aAAwCe,SAAxC;AACAH,4BAAiBZ,aAAjB,WAAsCgB,OAAtC;AACAH,iCAAsBb,aAAtB,KAAyCiB,MAAzC;AACAH,mBAAeA,iBAAiB,IAAjB,GAAwBI,KAAxB,GAAgCE,KAAKC,GAAL,CAASP,YAAT,EAAuBI,KAAvB,CAA/C;AACD;;AACD,SAAO;AAACN,gCAAD;AAAgBC,0CAAhB;AAAoCC;AAApC,GAAP;AACD","sourcesContent":["const ATTRIBUTE_MAPPING = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4'\n};\n\nexport function getShaders(transitions) {\n  // Build shaders\n  const varyings = [];\n  const attributeDeclarations = [];\n  const uniformsDeclarations = [];\n  const varyingDeclarations = [];\n  const calculations = [];\n\n  for (const attributeName in transitions) {\n    const transition = transitions[attributeName];\n    const attributeType = ATTRIBUTE_MAPPING[transition.attribute.size];\n\n    if (attributeType) {\n      transition.bufferIndex = varyings.length;\n      varyings.push(attributeName);\n\n      attributeDeclarations.push(`attribute ${attributeType} ${attributeName}From;`);\n      attributeDeclarations.push(`attribute ${attributeType} ${attributeName}To;`);\n      uniformsDeclarations.push(`uniform float ${attributeName}Time;`);\n      varyingDeclarations.push(`varying ${attributeType} ${attributeName};`);\n      calculations.push(`${attributeName} = mix(${attributeName}From, ${attributeName}To,\n        ${attributeName}Time);`);\n    }\n  }\n\n  const vs = `\n#define SHADER_NAME feedback-vertex-shader\n${attributeDeclarations.join('\\n')}\n${uniformsDeclarations.join('\\n')}\n${varyingDeclarations.join('\\n')}\n\nvoid main(void) {\n  ${calculations.join('\\n')}\n  gl_Position = vec4(0.0);\n}\n`;\n\n  const fs = `\\\n#define SHADER_NAME feedback-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n${varyingDeclarations.join('\\n')}\n\nvoid main(void) {\n  gl_FragColor = vec4(0.0);\n}\n`;\n  return {vs, fs, varyings};\n}\n\nexport function getBuffers(transitions) {\n  const sourceBuffers = {};\n  const destinationBuffers = {};\n  let elementCount = null;\n  for (const attributeName in transitions) {\n    const {fromState, toState, buffer, attribute} = transitions[attributeName];\n    const count = attribute.value.length / attribute.size;\n    sourceBuffers[`${attributeName}From`] = fromState;\n    sourceBuffers[`${attributeName}To`] = toState;\n    destinationBuffers[`${attributeName}`] = buffer;\n    elementCount = elementCount === null ? count : Math.min(elementCount, count);\n  }\n  return {sourceBuffers, destinationBuffers, elementCount};\n}\n"],"file":"attribute-transition-utils.js"}