{"version":3,"sources":["../../../../src/core/lib/seer-integration.js"],"names":["recursiveSet","obj","path","value","length","slice","overrides","Map","setPropOverrides","id","valuePath","seer","isReady","has","set","props","get","applyPropOverrides","overs","forEach","data","layerEditListener","listenFor","cb","seerInitListener","initLayerInSeer","layer","badges","constructor","layerName","listItem","links","state","model","undefined","parent","parentLayer","updateLayerInSeer","throttle","logPayload","multiUpdate","removeLayerInSeer","deleteItem","getAttributeManager","attrs","getAttributes","push","stats","getTimeString","timerQueryEnabled","lastFrameTime","toFixed"],"mappings":"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","sourcesContent":["import seer from 'seer';\n\n/**\n * Recursively set a nested property of an object given a properties array and a value\n */\nconst recursiveSet = (obj, path, value) => {\n  if (!obj) {\n    return;\n  }\n\n  if (path.length > 1) {\n    recursiveSet(obj[path[0]], path.slice(1), value);\n  } else {\n    obj[path[0]] = value;\n  }\n};\n\nconst overrides = new Map();\n\n/**\n * Create an override on the specify layer, indexed by a valuePath array.\n * Do nothing in case Seer as not been initialized to prevent any preformance drawback.\n */\nexport const setPropOverrides = (id, valuePath, value) => {\n  if (!seer.isReady()) {\n    return;\n  }\n\n  if (!overrides.has(id)) {\n    overrides.set(id, new Map());\n  }\n\n  const props = overrides.get(id);\n  props.set(valuePath, value);\n};\n\n/**\n * Get the props overrides of a specific layer if Seer as been initialized\n * Invalidates the data to be sure new ones are always picked up.\n */\nexport const applyPropOverrides = props => {\n  if (!seer.isReady() || !props.id) {\n    return;\n  }\n\n  const overs = overrides.get(props.id);\n  if (!overs) {\n    return;\n  }\n\n  overs.forEach((value, valuePath) => {\n    recursiveSet(props, valuePath, value);\n    // Invalidate data array if we have a data override\n    if (valuePath[0] === 'data') {\n      props.data = [...props.data];\n    }\n  });\n};\n\n/**\n * Listen for deck.gl edit events\n */\nexport const layerEditListener = cb => {\n  if (!seer.isReady()) {\n    return;\n  }\n\n  seer.listenFor('deck.gl', cb);\n};\n\n/**\n * Listen for seer init events to resend data\n */\nexport const seerInitListener = cb => {\n  if (!seer.isReady()) {\n    return;\n  }\n\n  seer.listenFor('init', cb);\n};\n\nexport const initLayerInSeer = layer => {\n  if (!seer.isReady() || !layer) {\n    return;\n  }\n\n  const badges = [layer.constructor.layerName];\n\n  seer.listItem('deck.gl', layer.id, {\n    badges,\n    // TODO: Seer currently only handles single model layers\n    links: layer.state && layer.state.model ? [`luma.gl:${layer.state.model.id}`] : undefined,\n    parent: layer.parentLayer ? layer.parentLayer.id : undefined\n  });\n};\n\n/**\n * Log layer's properties to Seer\n */\nexport const updateLayerInSeer = layer => {\n  if (!seer.isReady() || seer.throttle(`deck.gl:${layer.id}`, 1e3)) {\n    return;\n  }\n\n  const data = logPayload(layer);\n  seer.multiUpdate('deck.gl', layer.id, data);\n};\n\n/**\n * On finalize of a specify layer, remove it from seer\n */\nexport const removeLayerInSeer = id => {\n  if (!seer.isReady() || !id) {\n    return;\n  }\n\n  seer.deleteItem('deck.gl', id);\n};\n\nfunction logPayload(layer) {\n  const data = [{path: 'objects.props', data: layer.props}];\n\n  const badges = [layer.constructor.layerName];\n\n  if (layer.state) {\n    if (layer.getAttributeManager()) {\n      const attrs = layer.getAttributeManager().getAttributes();\n      data.push({path: 'objects.attributes', data: attrs});\n      badges.push(layer.getAttributeManager().stats.getTimeString());\n    }\n    // TODO: Seer currently only handles single model layers\n    if (layer.state.model) {\n      layer.state.model.timerQueryEnabled = true;\n      const {lastFrameTime} = layer.state.model.stats;\n      if (lastFrameTime) {\n        badges.push(`${(lastFrameTime * 1000).toFixed(0)}Î¼s`);\n      }\n    }\n  }\n\n  data.push({path: 'badges', data: badges});\n\n  return data;\n}\n"],"file":"seer-integration.js"}