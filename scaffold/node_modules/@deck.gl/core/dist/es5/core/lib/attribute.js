"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glArrayFromType = glArrayFromType;
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _luma = require("luma.gl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Attribute =
/*#__PURE__*/
function () {
  function Attribute() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$id = _ref.id,
        id = _ref$id === void 0 ? 'unnamed-attribute' : _ref$id,
        attribute = _ref.attribute,
        size = _ref.size,
        value = _ref.value,
        _ref$isGeneric = _ref.isGeneric,
        isGeneric = _ref$isGeneric === void 0 ? false : _ref$isGeneric,
        _ref$isIndexed = _ref.isIndexed,
        isIndexed = _ref$isIndexed === void 0 ? false : _ref$isIndexed,
        _ref$instanced = _ref.instanced,
        instanced = _ref$instanced === void 0 ? 0 : _ref$instanced,
        _ref$transition = _ref.transition,
        transition = _ref$transition === void 0 ? false : _ref$transition,
        _ref$noAlloc = _ref.noAlloc,
        noAlloc = _ref$noAlloc === void 0 ? false : _ref$noAlloc,
        _ref$updater = _ref.updater,
        updater = _ref$updater === void 0 ? null : _ref$updater,
        _ref$accessor = _ref.accessor,
        accessor = _ref$accessor === void 0 ? null : _ref$accessor;

    _classCallCheck(this, Attribute);

    this.id = id;
    this.userData = {}; // Reserved for application
    // Initialize the attribute descriptor, with WebGL and metadata fields

    this.state = Object.assign({
      // Ensure that fields are present before Object.seal()
      target: undefined,
      buffer: null,
      userData: {}
    }, {
      transition: transition,
      noAlloc: noAlloc,
      updater: updater,
      accessor: accessor
    }, // Metadata
    attribute, {
      // State
      isExternalBuffer: false,
      needsAlloc: false,
      needsUpdate: false,
      needsRedraw: false,
      // Luma fields
      isGeneric: isGeneric,
      isIndexed: isIndexed,
      instanced: instanced,
      size: size,
      value: value
    });
    this.allocedInstances = -1; // Sanity - no app fields on our attributes. Use userData instead.

    Object.seal(this);
    Object.seal(this.state); // Check all fields and generate helpful error messages

    this._validateAttributeDefinition();

    this._validateAttributeUpdaters();
  }

  _createClass(Attribute, [{
    key: "finalize",
    value: function finalize() {} // TODO call buffer.finalize();
    // HACK to fix plot layer (temporary)

  }, {
    key: "needsUpdate",
    value: function needsUpdate() {
      return this.state.needsUpdate;
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$clearChangedFla = _ref2.clearChangedFlags,
          clearChangedFlags = _ref2$clearChangedFla === void 0 ? false : _ref2$clearChangedFla;

      var needsRedraw = this.state.needsRedraw;
      this.state.needsRedraw = this.state.needsRedraw && !clearChangedFlags;
      return needsRedraw;
    }
  }, {
    key: "getInstanceCount",
    value: function getInstanceCount() {
      var attribute = this.state;
      return attribute.value !== null ? attribute.value.length / attribute.size : 0;
    }
  }, {
    key: "getBuffer",
    value: function getBuffer() {
      var attribute = this.state;
      return attribute.buffer || attribute;
    } // Checks that typed arrays for attributes are big enough
    // sets alloc flag if not
    // @return {Boolean} whether any updates are needed

  }, {
    key: "setNeedsUpdate",
    value: function setNeedsUpdate() {
      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;
      this.state.needsUpdate = this.state.needsUpdate || reason;
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;
      this.state.needsRedraw = this.state.needsRedraw || reason;
    }
  }, {
    key: "setNumInstances",
    value: function setNumInstances(numInstances) {
      var attribute = this.state;

      if (!attribute.isExternalBuffer) {
        // Do we need to reallocate the attribute's typed array?
        var instanceCount = this.getInstanceCount();
        var needsAlloc = instanceCount === 0 || instanceCount < numInstances;

        if (needsAlloc && (attribute.update || attribute.accessor)) {
          attribute.needsAlloc = true;
          this.setNeedsUpdate(this.id);
        }
      }
    }
  }, {
    key: "allocate",
    value: function allocate(numInstances) {
      this.setNumInstances(numInstances);
      var attribute = this.state; // Allocate a new typed array if needed

      if (attribute.needsAlloc) {
        // Allocate at least one element to ensure a valid buffer
        var allocCount = Math.max(numInstances, 1);
        var ArrayType = glArrayFromType(attribute.type || _luma.GL.FLOAT);
        attribute.value = new ArrayType(attribute.size * allocCount);
        attribute.needsAlloc = false;
        attribute.needsUpdate = true;
        this.allocedInstances = allocCount;
        return true;
      }

      return false;
    }
  }, {
    key: "update",
    value: function update(_ref3) {
      var numInstances = _ref3.numInstances,
          data = _ref3.data,
          props = _ref3.props,
          context = _ref3.context;

      if (!this.needsUpdate()) {
        return false;
      }

      var attribute = this.state;
      var update = attribute.update,
          accessor = attribute.accessor;
      var updated = true;

      if (update) {
        // Custom updater - typically for non-instanced layers
        update.call(context, attribute, {
          data: data,
          props: props,
          numInstances: numInstances
        });

        this._checkAttributeArray();
      } else if (accessor) {
        // Standard updater
        this._updateBufferViaStandardAccessor(data, props);

        this._checkAttributeArray();
      } else {
        updated = false;
      }

      attribute.needsUpdate = false;
      attribute.needsRedraw = true;
      return updated;
    }
  }, {
    key: "setExternalBuffer",
    value: function setExternalBuffer(buffer, numInstances) {
      var attribute = this.state;

      if (buffer) {
        attribute.isExternalBuffer = true;
        attribute.needsUpdate = false;

        if (_instanceof(buffer, _luma.Buffer)) {
          attribute.value = null;

          if (attribute.buffer !== buffer) {
            attribute.buffer = buffer;
            attribute.needsRedraw = true;
          }
        } else {
          var ArrayType = glArrayFromType(attribute.type || _luma.GL.FLOAT);

          if (!_instanceof(buffer, ArrayType)) {
            throw new Error("Attribute ".concat(this.id, " must be of type ").concat(ArrayType.name));
          }

          if (attribute.auto && buffer.length <= numInstances * attribute.size) {
            throw new Error('Attribute prop array must match length and size');
          }

          attribute.buffer = null;

          if (attribute.value !== buffer) {
            attribute.value = buffer;
            attribute.needsRedraw = true;
          }
        }
      } else {
        attribute.isExternalBuffer = false;
      }
    } // PRIVATE HELPER METHODS

  }, {
    key: "_updateBufferViaStandardAccessor",
    value: function _updateBufferViaStandardAccessor(data, props) {
      var attribute = this.state;
      var accessor = attribute.accessor,
          value = attribute.value,
          size = attribute.size;
      var accessorFunc = props[accessor];
      (0, _assert.default)(typeof accessorFunc === 'function', "accessor \"".concat(accessor, "\" is not a function"));
      var _attribute$defaultVal = attribute.defaultValue,
          defaultValue = _attribute$defaultVal === void 0 ? [0, 0, 0, 0] : _attribute$defaultVal;
      defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];
      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          var objectValue = accessorFunc(object);
          objectValue = Array.isArray(objectValue) ? objectValue : [objectValue];
          /* eslint-disable no-fallthrough, default-case */

          switch (size) {
            case 4:
              value[i + 3] = Number.isFinite(objectValue[3]) ? objectValue[3] : defaultValue[3];

            case 3:
              value[i + 2] = Number.isFinite(objectValue[2]) ? objectValue[2] : defaultValue[2];

            case 2:
              value[i + 1] = Number.isFinite(objectValue[1]) ? objectValue[1] : defaultValue[1];

            case 1:
              value[i + 0] = Number.isFinite(objectValue[0]) ? objectValue[0] : defaultValue[0];
          }

          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } // Validate luma.gl level fields

  }, {
    key: "_validateAttributeDefinition",
    value: function _validateAttributeDefinition() {
      var attribute = this.state;
      (0, _assert.default)(attribute.size >= 1 && attribute.size <= 4, "Attribute definition for ".concat(this.id, " invalid size"));
    } // Validate deck.gl level fields

  }, {
    key: "_validateAttributeUpdaters",
    value: function _validateAttributeUpdaters() {
      var attribute = this.state; // Check that either 'accessor' or 'update' is a valid function

      var hasUpdater = attribute.noAlloc || typeof attribute.update === 'function' || typeof attribute.accessor === 'string';

      if (!hasUpdater) {
        throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
      }
    }
  }, {
    key: "_checkAttributeArray",
    value: function _checkAttributeArray() {
      var attribute = this.state;
      var value = attribute.value;

      if (value && value.length >= 4) {
        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);

        if (!valid) {
          throw new Error("Illegal attribute generated for ".concat(this.id));
        }
      }
    }
  }, {
    key: "value",
    get: function get() {
      return this.state.value;
    }
  }]);

  return Attribute;
}();
/* eslint-disable complexity */


exports.default = Attribute;

function glArrayFromType(glType) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref4$clamped = _ref4.clamped,
      clamped = _ref4$clamped === void 0 ? true : _ref4$clamped;

  // Sorted in some order of likelihood to reduce amount of comparisons
  switch (glType) {
    case _luma.GL.FLOAT:
      return Float32Array;

    case _luma.GL.UNSIGNED_SHORT:
    case _luma.GL.UNSIGNED_SHORT_5_6_5:
    case _luma.GL.UNSIGNED_SHORT_4_4_4_4:
    case _luma.GL.UNSIGNED_SHORT_5_5_5_1:
      return Uint16Array;

    case _luma.GL.UNSIGNED_INT:
      return Uint32Array;

    case _luma.GL.UNSIGNED_BYTE:
      return clamped ? Uint8ClampedArray : Uint8Array;

    case _luma.GL.BYTE:
      return Int8Array;

    case _luma.GL.SHORT:
      return Int16Array;

    case _luma.GL.INT:
      return Int32Array;

    default:
      throw new Error('Failed to deduce type from array');
  }
}
/* eslint-enable complexity */
//# sourceMappingURL=attribute.js.map