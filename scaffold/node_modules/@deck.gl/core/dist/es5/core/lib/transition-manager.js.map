{"version":3,"sources":["../../../../src/core/lib/transition-manager.js"],"names":["noop","TRANSITION_EVENTS","BREAK","SNAP_TO_END","IGNORE","DEFAULT_PROPS","transitionDuration","transitionEasing","t","transitionInterpolator","LinearInterpolator","transitionInterruption","onTransitionStart","onTransitionInterrupt","onTransitionEnd","DEFAULT_STATE","animation","propsInTransition","startProps","endProps","TransitionManager","props","state","_onTransitionFrame","bind","nextProps","transitionTriggered","currentProps","_shouldIgnoreViewportChange","isTransitionInProgress","_isTransitionInProgress","_isTransitionEnabled","Object","assign","interruption","_triggerTransition","_endTransition","interpolator","arePropsEqual","_isUpdateDueToCurrentTransition","cancelAnimationFrame","initialProps","initializeProps","duration","easing","startTime","Date","now","start","end","requestAnimationFrame","_updateViewport","currentTime","shouldEnd","viewport","interpolateProps","onViewportChange","inTransition","defaultProps"],"mappings":"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","sourcesContent":["/* global requestAnimationFrame, cancelAnimationFrame */\nimport LinearInterpolator from '../transitions/linear-interpolator';\nimport {extractViewState} from '../transitions/transition-utils';\nimport assert from '../utils/assert';\n\nconst noop = () => {};\n\nexport const TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n};\n\nconst DEFAULT_PROPS = {\n  transitionDuration: 0,\n  transitionEasing: t => t,\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: noop,\n  onTransitionInterrupt: noop,\n  onTransitionEnd: noop\n};\n\nconst DEFAULT_STATE = {\n  animation: null,\n  propsInTransition: null,\n  startProps: null,\n  endProps: null\n};\n\nexport default class TransitionManager {\n  constructor(props) {\n    this.props = props;\n    this.state = DEFAULT_STATE;\n\n    this._onTransitionFrame = this._onTransitionFrame.bind(this);\n  }\n\n  // Returns current transitioned viewport.\n  getViewportInTransition() {\n    return this.state.propsInTransition;\n  }\n\n  // Process the vewiport change, either ignore or trigger a new transiton.\n  // Return true if a new transition is triggered, false otherwise.\n  processViewportChange(nextProps) {\n    let transitionTriggered = false;\n    const currentProps = this.props;\n    // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.\n    this.props = nextProps;\n\n    // NOTE: Be cautious re-ordering statements in this function.\n    if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n      return transitionTriggered;\n    }\n\n    const isTransitionInProgress = this._isTransitionInProgress();\n\n    if (this._isTransitionEnabled(nextProps)) {\n      const startProps = Object.assign(\n        {},\n        currentProps,\n        this.state.interruption === TRANSITION_EVENTS.SNAP_TO_END\n          ? this.state.endProps\n          : this.state.propsInTransition || currentProps\n      );\n\n      if (isTransitionInProgress) {\n        currentProps.onTransitionInterrupt();\n      }\n      nextProps.onTransitionStart();\n\n      this._triggerTransition(startProps, nextProps);\n\n      transitionTriggered = true;\n    } else if (isTransitionInProgress) {\n      currentProps.onTransitionInterrupt();\n      this._endTransition();\n    }\n\n    return transitionTriggered;\n  }\n\n  // Helper methods\n\n  _isTransitionInProgress() {\n    return this.state.propsInTransition;\n  }\n\n  _isTransitionEnabled(props) {\n    return props.transitionDuration > 0 && props.transitionInterpolator;\n  }\n\n  _isUpdateDueToCurrentTransition(props) {\n    if (this.state.propsInTransition) {\n      return this.state.interpolator.arePropsEqual(props, this.state.propsInTransition);\n    }\n    return false;\n  }\n\n  _shouldIgnoreViewportChange(currentProps, nextProps) {\n    if (this._isTransitionInProgress()) {\n      // Ignore update if it is requested to be ignored\n      return (\n        this.state.interruption === TRANSITION_EVENTS.IGNORE ||\n        // Ignore update if it is due to current active transition.\n        this._isUpdateDueToCurrentTransition(nextProps)\n      );\n    } else if (this._isTransitionEnabled(nextProps)) {\n      // Ignore if none of the viewport props changed.\n      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n    }\n    return true;\n  }\n\n  _triggerTransition(startProps, endProps) {\n    assert(this._isTransitionEnabled(endProps), 'Transition is not enabled');\n\n    cancelAnimationFrame(this.state.animation);\n\n    const initialProps = endProps.transitionInterpolator.initializeProps(startProps, endProps);\n\n    this.state = {\n      // Save current transition props\n      duration: endProps.transitionDuration,\n      easing: endProps.transitionEasing,\n      interpolator: endProps.transitionInterpolator,\n      interruption: endProps.transitionInterruption,\n\n      startTime: Date.now(),\n      startProps: initialProps.start,\n      endProps: initialProps.end,\n      animation: null,\n      propsInTransition: {}\n    };\n\n    this._onTransitionFrame();\n  }\n\n  _onTransitionFrame() {\n    // _updateViewport() may cancel the animation\n    this.state.animation = requestAnimationFrame(this._onTransitionFrame);\n    this._updateViewport();\n  }\n\n  _endTransition() {\n    cancelAnimationFrame(this.state.animation);\n    this.state = DEFAULT_STATE;\n  }\n\n  _updateViewport() {\n    // NOTE: Be cautious re-ordering statements in this function.\n    const currentTime = Date.now();\n    const {startTime, duration, easing, interpolator, startProps, endProps} = this.state;\n\n    let shouldEnd = false;\n    let t = (currentTime - startTime) / duration;\n    if (t >= 1) {\n      t = 1;\n      shouldEnd = true;\n    }\n    t = easing(t);\n\n    const viewport = interpolator.interpolateProps(startProps, endProps, t);\n\n    // This extractViewState gurantees angle props (bearing, longitude) are normalized\n    // So when viewports are compared they are in same range.\n    this.state.propsInTransition = extractViewState(Object.assign({}, this.props, viewport));\n\n    if (this.props.onViewportChange) {\n      this.props.onViewportChange(this.state.propsInTransition, {inTransition: true});\n    }\n\n    if (shouldEnd) {\n      this._endTransition();\n      this.props.onTransitionEnd();\n    }\n  }\n}\n\nTransitionManager.defaultProps = DEFAULT_PROPS;\n"],"file":"transition-manager.js"}