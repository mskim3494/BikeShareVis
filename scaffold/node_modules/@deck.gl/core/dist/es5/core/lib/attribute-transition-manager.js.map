{"version":3,"sources":["../../../../src/core/lib/attribute-transition-manager.js"],"names":["Transform","experimental","TRANSITION_STATE","NONE","PENDING","STARTED","ENDED","noop","AttributeTransitionManager","gl","id","attributeTransitions","needsRedraw","transform","isSupported","log","warn","attributes","opts","needsNewModel","changedTransitions","attributeName","transition","_updateAttribute","state","attribute","_createModel","sourceBuffers","destinationBuffers","elementCount","Math","min","update","animatedAttributes","buffer","currentTime","uniforms","time","startTime","onStart","duration","onEnd","name","easing","run","settings","_getTransitionSettings","hasChanged","_triggerTransition","delete","Object","assign","value","type","size","oldBufferData","Float32Array","getData","dstData","constructor","accessor","Array","isArray","map","a","find","Boolean","Number","isFinite","t","onInterrupt","transitionSettings","_normalizeTransitionSettings","needsNewBuffer","bufferSize","length","fromState","_getCurrentAttributeState","toState","Buffer","data","instanced","usage","GL","DYNAMIC_COPY"],"mappings":"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","sourcesContent":["import {GL, Buffer, experimental} from 'luma.gl';\nimport {getShaders, getBuffers} from './attribute-transition-utils';\nimport log from '../utils/log';\nimport assert from '../utils/assert';\n\nconst {Transform} = experimental;\n\nconst TRANSITION_STATE = {\n  NONE: 0,\n  PENDING: 1,\n  STARTED: 2,\n  ENDED: 3\n};\n\nconst noop = () => {};\n\nexport default class AttributeTransitionManager {\n  constructor(gl, {id}) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributeTransitions = {};\n    this.needsRedraw = false;\n    this.transform = null;\n\n    if (Transform.isSupported(gl)) {\n      this.isSupported = true;\n    } else {\n      log.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();\n    }\n  }\n\n  /* Public methods */\n\n  // Called when attribute manager updates\n  // Check the latest attributes for updates.\n  update(attributes, opts = {}) {\n    this.opts = opts;\n\n    if (!this.isSupported) {\n      return;\n    }\n\n    let needsNewModel = false;\n    const {attributeTransitions} = this;\n    const changedTransitions = {};\n\n    for (const attributeName in attributes) {\n      const transition = this._updateAttribute(attributeName, attributes[attributeName].state);\n\n      if (transition) {\n        if (!attributeTransitions[attributeName]) {\n          // New animated attribute is added\n          attributeTransitions[attributeName] = transition;\n          needsNewModel = true;\n        }\n        changedTransitions[attributeName] = transition;\n      }\n    }\n\n    for (const attributeName in attributeTransitions) {\n      const attribute = attributes[attributeName];\n\n      if (!attribute || !attribute.state.transition) {\n        // Animated attribute has been removed\n        delete attributeTransitions[attributeName];\n        needsNewModel = true;\n      }\n    }\n\n    if (needsNewModel) {\n      this._createModel();\n    } else if (this.transform) {\n      const {sourceBuffers, destinationBuffers, elementCount} = getBuffers(changedTransitions);\n      this.transform.elementCount = Math.min(this.transform.elementCount, elementCount);\n      this.transform.update({\n        sourceBuffers,\n        destinationBuffers\n      });\n    }\n  }\n\n  // Returns `true` if attribute is transition-enabled\n  hasAttribute(attributeName) {\n    return attributeName in this.attributeTransitions;\n  }\n\n  // Get all the animated attributes\n  getAttributes() {\n    const animatedAttributes = {};\n\n    for (const attributeName in this.attributeTransitions) {\n      const transition = this.attributeTransitions[attributeName];\n\n      if (transition.buffer) {\n        animatedAttributes[attributeName] = transition.buffer;\n      }\n    }\n\n    return animatedAttributes;\n  }\n\n  /* eslint-disable max-statements */\n  // Called every render cycle, run transform feedback\n  // Returns `true` if anything changes\n  setCurrentTime(currentTime) {\n    if (!this.transform) {\n      return false;\n    }\n\n    const uniforms = {};\n\n    let needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n\n    for (const attributeName in this.attributeTransitions) {\n      const transition = this.attributeTransitions[attributeName];\n\n      let time = 1;\n      if (transition.state === TRANSITION_STATE.PENDING) {\n        transition.startTime = currentTime;\n        transition.state = TRANSITION_STATE.STARTED;\n        transition.onStart(transition);\n      }\n\n      if (transition.state === TRANSITION_STATE.STARTED) {\n        time = (currentTime - transition.startTime) / transition.duration;\n        if (time >= 1) {\n          time = 1;\n          transition.state = TRANSITION_STATE.ENDED;\n          transition.onEnd(transition);\n        }\n        needsRedraw = true;\n      }\n      uniforms[`${transition.name}Time`] = transition.easing(time);\n    }\n\n    if (needsRedraw) {\n      this.transform.run({uniforms});\n    }\n\n    return needsRedraw;\n  }\n  /* eslint-enable max-statements */\n\n  /* Private methods */\n\n  // Check an attributes for updates\n  // Returns a transition object if a new transition is triggered.\n  _updateAttribute(attributeName, attribute) {\n    const settings = this._getTransitionSettings(attribute);\n\n    if (settings) {\n      let hasChanged;\n      let transition = this.attributeTransitions[attributeName];\n      if (transition) {\n        hasChanged = attribute.needsRedraw;\n      } else {\n        // New animated attributes have been added\n        transition = {name: attributeName, attribute};\n        hasChanged = true;\n      }\n\n      if (hasChanged) {\n        this._triggerTransition(transition, settings);\n        return transition;\n      }\n    }\n\n    return null;\n  }\n\n  // Create a model for the transform feedback\n  _createModel() {\n    if (this.transform) {\n      this.transform.delete();\n    }\n    this.transform = new Transform(\n      this.gl,\n      Object.assign(\n        {},\n        getBuffers(this.attributeTransitions),\n        getShaders(this.attributeTransitions)\n      )\n    );\n  }\n\n  // get current values of an attribute, clipped/padded to the size of the new buffer\n  _getCurrentAttributeState(transition) {\n    const {attribute, buffer} = transition;\n    const {value, type, size} = attribute;\n\n    if (buffer) {\n      // If new buffer is bigger than old buffer, back fill with destination values\n      let oldBufferData = new Float32Array(value);\n      buffer.getData({dstData: oldBufferData});\n      // Hack/Xiaoji: WebGL2 throws error if TransformFeedback does not render to\n      // a buffer of type Float32Array.\n      // Therefore we need to read data as a Float32Array then re-cast to attribute type\n      if (!(value instanceof Float32Array)) {\n        oldBufferData = new value.constructor(oldBufferData);\n      }\n      return {size, type, value: oldBufferData};\n    }\n    return {size, type, value};\n  }\n\n  // Returns transition settings object if transition is enabled, otherwise `null`\n  _getTransitionSettings(attribute) {\n    const {opts} = this;\n    const {transition, accessor} = attribute;\n\n    if (!transition) {\n      return null;\n    }\n\n    return Array.isArray(accessor) ? accessor.map(a => opts[a]).find(Boolean) : opts[accessor];\n  }\n\n  // Normalizes transition settings object, merge with default settings\n  _normalizeTransitionSettings(settings) {\n    // Shorthand: use duration instead of parameter object\n    if (Number.isFinite(settings)) {\n      settings = {duration: settings};\n    }\n\n    // Check if settings is valid\n    assert(settings && settings.duration > 0);\n\n    return {\n      duration: settings.duration,\n      easing: settings.easing || (t => t),\n      onStart: settings.onStart || noop,\n      onEnd: settings.onEnd || noop,\n      onInterrupt: settings.onInterrupt || noop\n    };\n  }\n\n  // Start a new transition using the current settings\n  // Updates transition state and from/to buffer\n  _triggerTransition(transition, settings) {\n    this.needsRedraw = true;\n\n    const {attribute, buffer} = transition;\n    const {value, size} = attribute;\n\n    const transitionSettings = this._normalizeTransitionSettings(settings);\n\n    const needsNewBuffer = !buffer || transition.bufferSize < value.length;\n\n    // Attribute descriptor to transition from\n    // _getCurrentAttributeState must be called before the current buffer is deleted\n    const fromState = this._getCurrentAttributeState(transition);\n\n    // Attribute descriptor to transition to\n    // Pre-converting to buffer to reuse in the case where no transition is needed\n    const toState = new Buffer(this.gl, {size, data: value});\n\n    if (needsNewBuffer) {\n      if (buffer) {\n        buffer.delete();\n      }\n\n      transition.buffer = new Buffer(this.gl, {\n        size,\n        instanced: attribute.instanced,\n        // WebGL2 throws error if `value` is not cast to Float32Array:\n        // `transformfeedback buffers : buffer or buffer range not large enough`\n        data: new Float32Array(value.length),\n        usage: GL.DYNAMIC_COPY\n      });\n      transition.bufferSize = value.length;\n    }\n\n    Object.assign(transition, transitionSettings);\n    if (transition.fromState) {\n      transition.fromState.delete();\n    }\n    transition.fromState = new Buffer(\n      this.gl,\n      Object.assign({}, fromState, {\n        data: fromState.value\n      })\n    );\n    if (transition.toState) {\n      transition.toState.delete();\n    }\n    transition.toState = toState;\n\n    // Reset transition state\n    if (transition.state === TRANSITION_STATE.STARTED) {\n      transition.onInterrupt(transition);\n    }\n    transition.state = TRANSITION_STATE.PENDING;\n  }\n}\n"],"file":"attribute-transition-manager.js"}