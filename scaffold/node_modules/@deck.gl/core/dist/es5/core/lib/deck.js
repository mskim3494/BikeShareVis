"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _layerManager = _interopRequireDefault(require("../lib/layer-manager"));

var _effectManager = _interopRequireDefault(require("../experimental/lib/effect-manager"));

var _effect = _interopRequireDefault(require("../experimental/lib/effect"));

var _log = _interopRequireDefault(require("../utils/log"));

var _mjolnir = require("mjolnir.js");

var _luma = require("luma.gl");

var _probe = require("probe.gl");

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/* global document */
function noop() {}

function getPropTypes(PropTypes) {
  // Note: Arrays (layers, views, ) can contain falsy values
  return {
    id: PropTypes.string,
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    // layer/view/controller settings
    layers: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    layerFilter: PropTypes.func,
    views: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    viewState: PropTypes.object,
    controller: PropTypes.func,
    effects: PropTypes.arrayOf(PropTypes.instanceOf(_effect.default)),
    // GL settings
    glOptions: PropTypes.object,
    gl: PropTypes.object,
    pickingRadius: PropTypes.number,
    onWebGLInitialized: PropTypes.func,
    onResize: PropTypes.func,
    onBeforeRender: PropTypes.func,
    onAfterRender: PropTypes.func,
    onLayerClick: PropTypes.func,
    onLayerHover: PropTypes.func,
    useDevicePixels: PropTypes.bool,
    // Debug settings
    debug: PropTypes.bool,
    drawPickingColors: PropTypes.bool
  };
}

var defaultProps = {
  id: 'deckgl-overlay',
  width: '100%',
  height: '100%',
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  gl: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  onWebGLInitialized: noop,
  onBeforeRender: noop,
  onAfterRender: noop,
  onLayerClick: null,
  onLayerHover: null,
  useDevicePixels: true,
  debug: false,
  drawPickingColors: false
};

var Deck =
/*#__PURE__*/
function () {
  function Deck(props) {
    _classCallCheck(this, Deck);

    props = Object.assign({}, defaultProps, props);
    this.width = 0; // "read-only", auto-updated from canvas

    this.height = 0; // "read-only", auto-updated from canvas

    this.needsRedraw = true;
    this.layerManager = null;
    this.effectManager = null;
    this.controller = null;
    this.stats = new _probe.Stats({
      id: 'deck.gl'
    }); // Bind methods

    this._onRendererInitialized = this._onRendererInitialized.bind(this);
    this._onRenderFrame = this._onRenderFrame.bind(this);
    this.canvas = this._createCanvas(props);
    this.controller = this._createController(props);
    this.animationLoop = this._createAnimationLoop(props);
    this.setProps(props);
    this.animationLoop.start();
  }

  _createClass(Deck, [{
    key: "finalize",
    value: function finalize() {
      this.animationLoop.stop();
      this.animationLoop = null;

      if (this.layerManager) {
        this.layerManager.finalize();
        this.layerManager = null;
      }

      if (this.controller) {
        this.controller.finalize();
        this.controller = null;
      }
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this.stats.timeStart('deck.setProps');
      props = Object.assign({}, this.props, props);
      this.props = props; // Update CSS size of canvas

      this._setCanvasSize(props); // We need to overwrite width and height with actual, numeric values


      var newProps = Object.assign({}, props, {
        viewState: this._getViewState(props),
        width: this.width,
        height: this.height
      }); // Update layer manager props (but not size)

      if (this.layerManager) {
        this.layerManager.setParameters(newProps);
      } // Update animation loop TODO - unify setParameters/setOptions/setProps etc naming.


      this.animationLoop.setProps(newProps); // Update controller props

      if (this.controller) {
        this.controller.setProps(newProps);
      }

      this.stats.timeEnd('deck.setProps');
    } // Public API

  }, {
    key: "pickObject",
    value: function pickObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          _ref$radius = _ref.radius,
          radius = _ref$radius === void 0 ? 0 : _ref$radius,
          _ref$layerIds = _ref.layerIds,
          layerIds = _ref$layerIds === void 0 ? null : _ref$layerIds;
      this.stats.timeStart('deck.pickObject');
      var selectedInfos = this.layerManager.pickObject({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds,
        mode: 'query'
      });
      this.stats.timeEnd('deck.pickObject');
      return selectedInfos.length ? selectedInfos[0] : null;
    }
  }, {
    key: "pickObjects",
    value: function pickObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$width = _ref2.width,
          width = _ref2$width === void 0 ? 1 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === void 0 ? 1 : _ref2$height,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds;
      this.stats.timeStart('deck.pickObjects');
      var infos = this.layerManager.pickObjects({
        x: x,
        y: y,
        width: width,
        height: height,
        layerIds: layerIds
      });
      this.stats.timeEnd('deck.pickObjects');
      return infos;
    }
  }, {
    key: "getViewports",
    value: function getViewports() {
      return this.layerManager ? this.layerManager.getViewports() : [];
    } // Private Methods
    // canvas, either string, canvas or `null`

  }, {
    key: "_createCanvas",
    value: function _createCanvas(props) {
      var canvas = props.canvas; // TODO EventManager should accept element id

      if (typeof canvas === 'string') {
        /* global document */
        canvas = document.getElementById(canvas);
        (0, _assert.default)(canvas);
      }

      if (!canvas) {
        canvas = document.createElement('canvas');
        var parent = props.parent || document.body;
        parent.appendChild(canvas);
      }

      var id = props.id,
          style = props.style;
      canvas.id = id;
      Object.assign(canvas.style, style);
      return canvas;
    } // Updates canvas width and/or height, if provided as props

  }, {
    key: "_setCanvasSize",
    value: function _setCanvasSize(props) {
      var canvas = this.canvas;
      var width = props.width,
          height = props.height; // Set size ONLY if props are being provided, otherwise let canvas be layouted freely

      if (width || width === 0) {
        width = Number.isFinite(width) ? "".concat(width, "px") : width;
        canvas.style.width = width;
      }

      if (height || height === 0) {
        height = Number.isFinite(height) ? "".concat(height, "px") : height;
        canvas.style.height = height;
      }
    } // If canvas size has changed, updates

  }, {
    key: "_updateCanvasSize",
    value: function _updateCanvasSize() {
      if (this._checkForCanvasSizeChange()) {
        var width = this.width,
            height = this.height;
        this.layerManager.setParameters({
          width: width,
          height: height
        });

        if (this.controller) {
          this.controller.setProps({
            viewState: this._getViewState(this.props),
            width: this.width,
            height: this.height
          });
        }

        if (this.props.onResize) {
          this.props.onResize({
            width: this.width,
            height: this.height
          });
        }
      }
    } // If canvas size has changed, reads out the new size and returns true

  }, {
    key: "_checkForCanvasSizeChange",
    value: function _checkForCanvasSizeChange() {
      var canvas = this.canvas;

      if (canvas && (this.width !== canvas.clientWidth || this.height !== canvas.clientHeight)) {
        this.width = canvas.clientWidth;
        this.height = canvas.clientHeight;
        return true;
      }

      return false;
    } // Note: props.controller must be a class constructor, not an already created instance

  }, {
    key: "_createController",
    value: function _createController(props) {
      var Controller = props.controller;

      if (Controller) {
        return new Controller(Object.assign({}, this._getViewState(props), props, {
          canvas: this.canvas
        }));
      }

      return null;
    }
  }, {
    key: "_createAnimationLoop",
    value: function _createAnimationLoop(props) {
      var _this = this;

      var width = props.width,
          height = props.height,
          gl = props.gl,
          glOptions = props.glOptions,
          debug = props.debug,
          useDevicePixels = props.useDevicePixels,
          autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      return new _luma.AnimationLoop({
        width: width,
        height: height,
        useDevicePixels: useDevicePixels,
        autoResizeDrawingBuffer: autoResizeDrawingBuffer,
        onCreateContext: function onCreateContext(opts) {
          return gl || (0, _luma.createGLContext)(Object.assign({}, glOptions, {
            canvas: _this.canvas,
            debug: debug
          }));
        },
        onInitialize: this._onRendererInitialized,
        onRender: this._onRenderFrame,
        onBeforeRender: props.onBeforeRender,
        onAfterRender: props.onAfterRender
      });
    }
  }, {
    key: "_getViewState",
    value: function _getViewState(props) {
      return Object.assign({}, props.viewState || {}, {
        width: this.width,
        height: this.height
      });
    } // Callbacks

  }, {
    key: "_onRendererInitialized",
    value: function _onRendererInitialized(_ref3) {
      var gl = _ref3.gl,
          canvas = _ref3.canvas;
      (0, _luma.setParameters)(gl, {
        blend: true,
        blendFunc: [_luma.GL.SRC_ALPHA, _luma.GL.ONE_MINUS_SRC_ALPHA, _luma.GL.ONE, _luma.GL.ONE_MINUS_SRC_ALPHA],
        polygonOffsetFill: true,
        depthTest: true,
        depthFunc: _luma.GL.LEQUAL
      });
      this.props.onWebGLInitialized(gl); // Note: avoid React setState due GL animation loop / setState timing issue

      this.layerManager = new _layerManager.default(gl, {
        eventManager: new _mjolnir.EventManager(canvas),
        stats: this.stats
      });
      this.effectManager = new _effectManager.default({
        gl: gl,
        layerManager: this.layerManager
      });
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.props.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;
          this.effectManager.addEffect(effect);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.setProps(this.props);

      this._updateCanvasSize();
    }
  }, {
    key: "_onRenderFrame",
    value: function _onRenderFrame(_ref4) {
      var gl = _ref4.gl;

      if (this.stats.oneSecondPassed()) {
        var table = this.stats.getStatsTable();
        this.stats.reset();

        _log.default.table(1, table)();
      }

      this._updateCanvasSize(); // Update layers if needed (e.g. some async prop has loaded)


      this.layerManager.updateLayers();
      this.stats.bump('fps');
      var redrawReason = this.layerManager.needsRedraw({
        clearRedrawFlags: true
      });

      if (!redrawReason) {
        return;
      }

      this.stats.bump('render-fps');

      if (this.props.onBeforeRender) {
        this.props.onBeforeRender({
          gl: gl
        }); // TODO - should be called by AnimationLoop
      }

      this.layerManager.drawLayers({
        pass: 'screen',
        redrawReason: redrawReason,
        // Helps debug layer picking, especially in framebuffer powered layers
        drawPickingColors: this.props.drawPickingColors
      });

      if (this.props.onAfterRender) {
        this.props.onAfterRender({
          gl: gl
        }); // TODO - should be called by AnimationLoop
      }
    }
  }]);

  return Deck;
}();

exports.default = Deck;
Deck.displayName = 'Deck';
Deck.getPropTypes = getPropTypes;
Deck.defaultProps = defaultProps;
//# sourceMappingURL=deck.js.map