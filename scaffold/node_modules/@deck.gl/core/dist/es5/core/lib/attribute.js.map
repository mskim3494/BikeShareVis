{"version":3,"sources":["../../../../src/core/lib/attribute.js"],"names":["Attribute","id","attribute","size","value","isGeneric","isIndexed","instanced","transition","noAlloc","updater","accessor","userData","state","Object","assign","target","undefined","buffer","isExternalBuffer","needsAlloc","needsUpdate","needsRedraw","allocedInstances","seal","_validateAttributeDefinition","_validateAttributeUpdaters","clearChangedFlags","length","reason","numInstances","instanceCount","getInstanceCount","update","setNeedsUpdate","setNumInstances","allocCount","Math","max","ArrayType","glArrayFromType","type","GL","FLOAT","data","props","context","updated","call","_checkAttributeArray","_updateBufferViaStandardAccessor","Buffer","Error","name","auto","accessorFunc","defaultValue","Array","isArray","i","object","objectValue","Number","isFinite","hasUpdater","valid","glType","clamped","Float32Array","UNSIGNED_SHORT","UNSIGNED_SHORT_5_6_5","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","Uint16Array","UNSIGNED_INT","Uint32Array","UNSIGNED_BYTE","Uint8ClampedArray","Uint8Array","BYTE","Int8Array","SHORT","Int16Array","INT","Int32Array"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport assert from 'assert';\nimport {GL, Buffer} from 'luma.gl';\n\nexport default class Attribute {\n  constructor({\n    id = 'unnamed-attribute',\n    attribute,\n\n    // luma.gl fields\n    size,\n    value,\n    isGeneric = false,\n    isIndexed = false,\n    instanced = 0,\n\n    // deck.gl fields\n    transition = false,\n    noAlloc = false,\n    updater = null,\n    accessor = null\n  } = {}) {\n    this.id = id;\n    this.userData = {}; // Reserved for application\n\n    // Initialize the attribute descriptor, with WebGL and metadata fields\n    this.state = Object.assign(\n      {\n        // Ensure that fields are present before Object.seal()\n        target: undefined,\n        buffer: null,\n        userData: {}\n      },\n      {\n        transition,\n        noAlloc,\n        updater,\n        accessor\n      },\n      // Metadata\n      attribute,\n      {\n        // State\n        isExternalBuffer: false,\n        needsAlloc: false,\n        needsUpdate: false,\n        needsRedraw: false,\n\n        // Luma fields\n        isGeneric,\n        isIndexed,\n        instanced,\n        size,\n        value\n      }\n    );\n\n    this.allocedInstances = -1;\n\n    // Sanity - no app fields on our attributes. Use userData instead.\n    Object.seal(this);\n    Object.seal(this.state);\n\n    // Check all fields and generate helpful error messages\n    this._validateAttributeDefinition();\n    this._validateAttributeUpdaters();\n  }\n\n  finalize() {\n    // TODO call buffer.finalize();\n  }\n\n  // HACK to fix plot layer (temporary)\n  get value() {\n    return this.state.value;\n  }\n\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({clearChangedFlags = false} = {}) {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = this.state.needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getInstanceCount() {\n    const attribute = this.state;\n    return attribute.value !== null ? attribute.value.length / attribute.size : 0;\n  }\n\n  getBuffer() {\n    const attribute = this.state;\n    return attribute.buffer || attribute;\n  }\n\n  // Checks that typed arrays for attributes are big enough\n  // sets alloc flag if not\n  // @return {Boolean} whether any updates are needed\n  setNeedsUpdate(reason = this.id) {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n  }\n\n  setNeedsRedraw(reason = this.id) {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  setNumInstances(numInstances) {\n    const attribute = this.state;\n\n    if (!attribute.isExternalBuffer) {\n      // Do we need to reallocate the attribute's typed array?\n      const instanceCount = this.getInstanceCount();\n      const needsAlloc = instanceCount === 0 || instanceCount < numInstances;\n      if (needsAlloc && (attribute.update || attribute.accessor)) {\n        attribute.needsAlloc = true;\n        this.setNeedsUpdate(this.id);\n      }\n    }\n  }\n\n  allocate(numInstances) {\n    this.setNumInstances(numInstances);\n\n    const attribute = this.state;\n\n    // Allocate a new typed array if needed\n    if (attribute.needsAlloc) {\n      // Allocate at least one element to ensure a valid buffer\n      const allocCount = Math.max(numInstances, 1);\n      const ArrayType = glArrayFromType(attribute.type || GL.FLOAT);\n\n      attribute.value = new ArrayType(attribute.size * allocCount);\n      attribute.needsAlloc = false;\n      attribute.needsUpdate = true;\n\n      this.allocedInstances = allocCount;\n      return true;\n    }\n\n    return false;\n  }\n\n  update({numInstances, data, props, context}) {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const attribute = this.state;\n\n    const {update, accessor} = attribute;\n\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      update.call(context, attribute, {data, props, numInstances});\n      this._checkAttributeArray();\n    } else if (accessor) {\n      // Standard updater\n      this._updateBufferViaStandardAccessor(data, props);\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    attribute.needsUpdate = false;\n    attribute.needsRedraw = true;\n\n    return updated;\n  }\n\n  setExternalBuffer(buffer, numInstances) {\n    const attribute = this.state;\n\n    if (buffer) {\n      attribute.isExternalBuffer = true;\n      attribute.needsUpdate = false;\n\n      if (buffer instanceof Buffer) {\n        attribute.value = null;\n        if (attribute.buffer !== buffer) {\n          attribute.buffer = buffer;\n          attribute.needsRedraw = true;\n        }\n      } else {\n        const ArrayType = glArrayFromType(attribute.type || GL.FLOAT);\n        if (!(buffer instanceof ArrayType)) {\n          throw new Error(`Attribute ${this.id} must be of type ${ArrayType.name}`);\n        }\n        if (attribute.auto && buffer.length <= numInstances * attribute.size) {\n          throw new Error('Attribute prop array must match length and size');\n        }\n\n        attribute.buffer = null;\n        if (attribute.value !== buffer) {\n          attribute.value = buffer;\n          attribute.needsRedraw = true;\n        }\n      }\n    } else {\n      attribute.isExternalBuffer = false;\n    }\n  }\n\n  // PRIVATE HELPER METHODS\n\n  _updateBufferViaStandardAccessor(data, props) {\n    const attribute = this.state;\n\n    const {accessor, value, size} = attribute;\n    const accessorFunc = props[accessor];\n\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let {defaultValue = [0, 0, 0, 0]} = attribute;\n    defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];\n    let i = 0;\n    for (const object of data) {\n      let objectValue = accessorFunc(object);\n      objectValue = Array.isArray(objectValue) ? objectValue : [objectValue];\n      /* eslint-disable no-fallthrough, default-case */\n      switch (size) {\n        case 4:\n          value[i + 3] = Number.isFinite(objectValue[3]) ? objectValue[3] : defaultValue[3];\n        case 3:\n          value[i + 2] = Number.isFinite(objectValue[2]) ? objectValue[2] : defaultValue[2];\n        case 2:\n          value[i + 1] = Number.isFinite(objectValue[1]) ? objectValue[1] : defaultValue[1];\n        case 1:\n          value[i + 0] = Number.isFinite(objectValue[0]) ? objectValue[0] : defaultValue[0];\n      }\n      i += size;\n    }\n  }\n\n  // Validate luma.gl level fields\n  _validateAttributeDefinition() {\n    const attribute = this.state;\n\n    assert(\n      attribute.size >= 1 && attribute.size <= 4,\n      `Attribute definition for ${this.id} invalid size`\n    );\n  }\n\n  // Validate deck.gl level fields\n  _validateAttributeUpdaters() {\n    const attribute = this.state;\n\n    // Check that either 'accessor' or 'update' is a valid function\n    const hasUpdater =\n      attribute.noAlloc ||\n      typeof attribute.update === 'function' ||\n      typeof attribute.accessor === 'string';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n\n  _checkAttributeArray() {\n    const attribute = this.state;\n\n    const {value} = attribute;\n    if (value && value.length >= 4) {\n      const valid =\n        Number.isFinite(value[0]) &&\n        Number.isFinite(value[1]) &&\n        Number.isFinite(value[2]) &&\n        Number.isFinite(value[3]);\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n}\n\n/* eslint-disable complexity */\nexport function glArrayFromType(glType, {clamped = true} = {}) {\n  // Sorted in some order of likelihood to reduce amount of comparisons\n  switch (glType) {\n    case GL.FLOAT:\n      return Float32Array;\n    case GL.UNSIGNED_SHORT:\n    case GL.UNSIGNED_SHORT_5_6_5:\n    case GL.UNSIGNED_SHORT_4_4_4_4:\n    case GL.UNSIGNED_SHORT_5_5_5_1:\n      return Uint16Array;\n    case GL.UNSIGNED_INT:\n      return Uint32Array;\n    case GL.UNSIGNED_BYTE:\n      return clamped ? Uint8ClampedArray : Uint8Array;\n    case GL.BYTE:\n      return Int8Array;\n    case GL.SHORT:\n      return Int16Array;\n    case GL.INT:\n      return Int32Array;\n    default:\n      throw new Error('Failed to deduce type from array');\n  }\n}\n/* eslint-enable complexity */\n"],"file":"attribute.js"}