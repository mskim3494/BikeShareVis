"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getShaders = getShaders;
exports.getBuffers = getBuffers;
var ATTRIBUTE_MAPPING = {
  1: 'float',
  2: 'vec2',
  3: 'vec3',
  4: 'vec4'
};

function getShaders(transitions) {
  // Build shaders
  var varyings = [];
  var attributeDeclarations = [];
  var uniformsDeclarations = [];
  var varyingDeclarations = [];
  var calculations = [];

  for (var attributeName in transitions) {
    var transition = transitions[attributeName];
    var attributeType = ATTRIBUTE_MAPPING[transition.attribute.size];

    if (attributeType) {
      transition.bufferIndex = varyings.length;
      varyings.push(attributeName);
      attributeDeclarations.push("attribute ".concat(attributeType, " ").concat(attributeName, "From;"));
      attributeDeclarations.push("attribute ".concat(attributeType, " ").concat(attributeName, "To;"));
      uniformsDeclarations.push("uniform float ".concat(attributeName, "Time;"));
      varyingDeclarations.push("varying ".concat(attributeType, " ").concat(attributeName, ";"));
      calculations.push("".concat(attributeName, " = mix(").concat(attributeName, "From, ").concat(attributeName, "To,\n        ").concat(attributeName, "Time);"));
    }
  }

  var vs = "\n#define SHADER_NAME feedback-vertex-shader\n".concat(attributeDeclarations.join('\n'), "\n").concat(uniformsDeclarations.join('\n'), "\n").concat(varyingDeclarations.join('\n'), "\n\nvoid main(void) {\n  ").concat(calculations.join('\n'), "\n  gl_Position = vec4(0.0);\n}\n");
  var fs = "#define SHADER_NAME feedback-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n".concat(varyingDeclarations.join('\n'), "\n\nvoid main(void) {\n  gl_FragColor = vec4(0.0);\n}\n");
  return {
    vs: vs,
    fs: fs,
    varyings: varyings
  };
}

function getBuffers(transitions) {
  var sourceBuffers = {};
  var destinationBuffers = {};
  var elementCount = null;

  for (var attributeName in transitions) {
    var _transitions$attribut = transitions[attributeName],
        fromState = _transitions$attribut.fromState,
        toState = _transitions$attribut.toState,
        buffer = _transitions$attribut.buffer,
        attribute = _transitions$attribut.attribute;
    var count = attribute.value.length / attribute.size;
    sourceBuffers["".concat(attributeName, "From")] = fromState;
    sourceBuffers["".concat(attributeName, "To")] = toState;
    destinationBuffers["".concat(attributeName)] = buffer;
    elementCount = elementCount === null ? count : Math.min(elementCount, count);
  }

  return {
    sourceBuffers: sourceBuffers,
    destinationBuffers: destinationBuffers,
    elementCount: elementCount
  };
}
//# sourceMappingURL=attribute-transition-utils.js.map