{"version":3,"sources":["../../../../src/core/lib/pick-layers.js"],"names":["NO_PICKED_OBJECT","pickedColor","pickedLayer","pickedObjectIndex","pickObject","gl","layers","viewports","x","y","radius","layerFilter","mode","onViewportActive","pickingFBO","lastPickedInfo","useDevicePixels","pixelRatio","deviceX","Math","round","deviceY","canvas","height","deviceRadius","deviceRect","getPickingRect","deviceWidth","width","deviceHeight","pickedColors","drawAndSamplePickingBuffer","redrawReason","pickInfo","getClosestFromPickingBuffer","processPickInfo","pickVisibleObjects","deviceLeft","deviceBottom","deviceRight","deviceTop","pickInfos","getUniquesFromPickingBuffer","uniqueInfos","Map","forEach","info","color","layer","index","picked","getLayerPickingInfo","has","object","set","Array","from","values","Number","isFinite","pickableLayers","filter","isPickable","length","Uint8Array","readPixels","pixelArray","getViewportFromCoordinates","viewport","valid","max","min","affectedLayers","lastPickedObjectIndex","lastPickedLayerId","layerId","pickedLayerId","props","id","lastPickedLayer","find","unshift","baseInfo","pixel","lngLat","unproject","devicePixel","infos","Object","assign","pickingSelectedColor","autoHighlight","pickingParameters","getModels","model","updateModuleSettings","unhandledPickInfos","callLayerPickingCallbacks","handled","onClick","onHover","Error","push","minSquareDistanceToCenter","closestPixelIndex","i","row","dy","dy2","col","pickedLayerIndex","dx","d2","slice","decodePickingColor","log","error","uniqueColors","colorKey","join","sourceLayer","pickLayer","parentLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {drawPickingBuffer, getPixelRatio} from './draw-layers';\nimport log from '../utils/log';\nimport assert from '../utils/assert';\n\nconst NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedLayer: null,\n  pickedObjectIndex: -1\n};\n\n/* eslint-disable max-depth, max-statements */\n// Pick the closest object at the given (x,y) coordinate\nexport function pickObject(\n  gl,\n  {\n    layers,\n    viewports,\n    x,\n    y,\n    radius,\n    layerFilter,\n    mode,\n    onViewportActive,\n    pickingFBO,\n    lastPickedInfo,\n    useDevicePixels\n  }\n) {\n  // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n  const pixelRatio = getPixelRatio({useDevicePixels});\n  const deviceX = Math.round(x * pixelRatio);\n  const deviceY = Math.round(gl.canvas.height - y * pixelRatio);\n  const deviceRadius = Math.round(radius * pixelRatio);\n\n  const deviceRect = getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth: pickingFBO.width,\n    deviceHeight: pickingFBO.height\n  });\n\n  const pickedColors =\n    deviceRect &&\n    drawAndSamplePickingBuffer(gl, {\n      layers,\n      viewports,\n      onViewportActive,\n      useDevicePixels,\n      pickingFBO,\n      deviceRect,\n      layerFilter,\n      redrawReason: mode\n    });\n\n  const pickInfo =\n    (pickedColors &&\n      getClosestFromPickingBuffer(gl, {\n        pickedColors,\n        layers,\n        deviceX,\n        deviceY,\n        deviceRadius,\n        deviceRect\n      })) ||\n    NO_PICKED_OBJECT;\n\n  return processPickInfo({\n    pickInfo,\n    lastPickedInfo,\n    mode,\n    layers,\n    viewports,\n    x,\n    y,\n    deviceX,\n    deviceY,\n    pixelRatio\n  });\n}\n\n// Pick all objects within the given bounding box\nexport function pickVisibleObjects(\n  gl,\n  {\n    layers,\n    viewports,\n    x,\n    y,\n    width,\n    height,\n    mode,\n    layerFilter,\n    onViewportActive,\n    pickingFBO,\n    useDevicePixels\n  }\n) {\n  // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n  const pixelRatio = getPixelRatio({useDevicePixels});\n\n  const deviceLeft = Math.round(x * pixelRatio);\n  const deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);\n  const deviceRight = Math.round((x + width) * pixelRatio);\n  const deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);\n\n  const deviceRect = {\n    x: deviceLeft,\n    y: deviceTop,\n    width: deviceRight - deviceLeft,\n    height: deviceBottom - deviceTop\n  };\n\n  const pickedColors = drawAndSamplePickingBuffer(gl, {\n    layers,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    useDevicePixels,\n    deviceRect,\n    layerFilter,\n    redrawReason: mode\n  });\n\n  const pickInfos = getUniquesFromPickingBuffer(gl, {pickedColors, layers});\n\n  // Only return unique infos, identified by info.object\n  const uniqueInfos = new Map();\n\n  pickInfos.forEach(pickInfo => {\n    let info = {\n      color: pickInfo.pickedColor,\n      layer: null,\n      index: pickInfo.pickedObjectIndex,\n      picked: true,\n      x,\n      y,\n      width,\n      height,\n      pixelRatio\n    };\n\n    info = getLayerPickingInfo({layer: pickInfo.pickedLayer, info, mode});\n    if (!uniqueInfos.has(info.object)) {\n      uniqueInfos.set(info.object, info);\n    }\n  });\n\n  return Array.from(uniqueInfos.values());\n}\n\n// HELPER METHODS\n\n// returns pickedColor or null if no pickable layers found.\nfunction drawAndSamplePickingBuffer(\n  gl,\n  {\n    layers,\n    viewports,\n    onViewportActive,\n    useDevicePixels,\n    pickingFBO,\n    deviceRect,\n    layerFilter,\n    redrawReason\n  }\n) {\n  assert(deviceRect);\n  assert(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');\n  assert(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');\n\n  const pickableLayers = layers.filter(layer => layer.isPickable());\n  if (pickableLayers.length < 1) {\n    return null;\n  }\n\n  drawPickingBuffer(gl, {\n    layers,\n    viewports,\n    onViewportActive,\n    useDevicePixels,\n    pickingFBO,\n    deviceRect,\n    layerFilter,\n    redrawReason\n  });\n\n  // Read from an already rendered picking buffer\n  // Returns an Uint8ClampedArray of picked pixels\n  const {x, y, width, height} = deviceRect;\n  const pickedColors = new Uint8Array(width * height * 4);\n  pickingFBO.readPixels({x, y, width, height, pixelArray: pickedColors});\n  return pickedColors;\n}\n\n// Indentifies which viewport, if any corresponds to x and y\n// Returns first viewport if no match\n// TODO - need to determine which viewport we are in\n// TODO - document concept of \"primary viewport\" that matches all coords?\n// TODO - static method on Viewport class?\nfunction getViewportFromCoordinates({viewports}) {\n  const viewport = viewports[0];\n  return viewport;\n}\n\n// Calculate a picking rect centered on deviceX and deviceY and clipped to device\n// Returns null if pixel is outside of device\nfunction getPickingRect({deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight}) {\n  const valid = deviceX >= 0 && deviceY >= 0 && deviceX < deviceWidth && deviceY < deviceHeight;\n\n  // x, y out of bounds.\n  if (!valid) {\n    return null;\n  }\n\n  // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n  const x = Math.max(0, deviceX - deviceRadius);\n  const y = Math.max(0, deviceY - deviceRadius);\n  const width = Math.min(deviceWidth, deviceX + deviceRadius) - x + 1;\n  const height = Math.min(deviceHeight, deviceY + deviceRadius) - y + 1;\n\n  return {x, y, width, height};\n}\n\n// TODO - break this monster function into 3+ parts\nfunction processPickInfo({\n  pickInfo,\n  lastPickedInfo,\n  mode,\n  layers,\n  viewports,\n  x,\n  y,\n  deviceX,\n  deviceY,\n  pixelRatio\n}) {\n  const {pickedColor, pickedLayer, pickedObjectIndex} = pickInfo;\n\n  const affectedLayers = pickedLayer ? [pickedLayer] : [];\n\n  if (mode === 'hover') {\n    // only invoke onHover events if picked object has changed\n    const lastPickedObjectIndex = lastPickedInfo.index;\n    const lastPickedLayerId = lastPickedInfo.layerId;\n    const pickedLayerId = pickedLayer && pickedLayer.props.id;\n\n    // proceed only if picked object changed\n    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {\n      if (pickedLayerId !== lastPickedLayerId) {\n        // We cannot store a ref to lastPickedLayer in the context because\n        // the state of an outdated layer is no longer valid\n        // and the props may have changed\n        const lastPickedLayer = layers.find(layer => layer.props.id === lastPickedLayerId);\n        if (lastPickedLayer) {\n          // Let leave event fire before enter event\n          affectedLayers.unshift(lastPickedLayer);\n        }\n      }\n\n      // Update layer manager context\n      lastPickedInfo.layerId = pickedLayerId;\n      lastPickedInfo.index = pickedObjectIndex;\n    }\n  }\n\n  const viewport = getViewportFromCoordinates({viewports}); // TODO - add coords\n\n  const baseInfo = {\n    color: null,\n    layer: null,\n    index: -1,\n    picked: false,\n    x,\n    y,\n    pixel: [x, y],\n    lngLat: viewport.unproject([x, y]),\n    devicePixel: [deviceX, deviceY],\n    pixelRatio\n  };\n\n  // Use a Map to store all picking infos.\n  // The following two forEach loops are the result of\n  // https://github.com/uber/deck.gl/issues/443\n  // Please be very careful when changing this pattern\n  const infos = new Map();\n\n  affectedLayers.forEach(layer => {\n    let info = Object.assign({}, baseInfo);\n\n    if (layer === pickedLayer) {\n      info.color = pickedColor;\n      info.index = pickedObjectIndex;\n      info.picked = true;\n    }\n\n    info = getLayerPickingInfo({layer, info, mode});\n\n    // This guarantees that there will be only one copy of info for\n    // one composite layer\n    if (info) {\n      infos.set(info.layer.id, info);\n    }\n\n    const pickingSelectedColor =\n      layer.props.autoHighlight && pickedLayer === layer ? pickedColor : null;\n\n    const pickingParameters = {\n      pickingSelectedColor\n    };\n\n    for (const model of layer.getModels()) {\n      model.updateModuleSettings(pickingParameters);\n    }\n  });\n\n  const unhandledPickInfos = callLayerPickingCallbacks(infos, mode);\n\n  return unhandledPickInfos;\n}\n\n// Per-layer event handlers (e.g. onClick, onHover) are provided by the\n// user and out of deck.gl's control. It's very much possible that\n// the user calls React lifecycle methods in these function, such as\n// ReactComponent.setState(). React lifecycle methods sometimes induce\n// a re-render and re-generation of props of deck.gl and its layers,\n// which invalidates all layers currently passed to this very function.\n\n// Therefore, per-layer event handlers must be invoked at the end\n// of the picking operation. NO operation that relies on the states of current\n// layers should be called after this code.\nfunction callLayerPickingCallbacks(infos, mode) {\n  const unhandledPickInfos = [];\n\n  infos.forEach(info => {\n    let handled = false;\n    switch (mode) {\n      case 'click':\n        handled = info.layer.props.onClick(info);\n        break;\n      case 'hover':\n        handled = info.layer.props.onHover(info);\n        break;\n      case 'query':\n        break;\n      default:\n        throw new Error('unknown pick type');\n    }\n\n    if (!handled) {\n      unhandledPickInfos.push(info);\n    }\n  });\n\n  return unhandledPickInfos;\n}\n\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getClosestFromPickingBuffer(\n  gl,\n  {pickedColors, layers, deviceX, deviceY, deviceRadius, deviceRect}\n) {\n  assert(pickedColors);\n\n  // Traverse all pixels in picking results and find the one closest to the supplied\n  // [deviceX, deviceY]\n  const {x, y, width, height} = deviceRect;\n  let minSquareDistanceToCenter = deviceRadius * deviceRadius;\n  let closestPixelIndex = -1;\n  let i = 0;\n\n  for (let row = 0; row < height; row++) {\n    const dy = row + y - deviceY;\n    const dy2 = dy * dy;\n\n    if (dy2 > minSquareDistanceToCenter) {\n      // skip this row\n      i += 4 * width;\n    } else {\n      for (let col = 0; col < width; col++) {\n        // Decode picked layer from color\n        const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n        if (pickedLayerIndex >= 0) {\n          const dx = col + x - deviceX;\n          const d2 = dx * dx + dy2;\n\n          if (d2 <= minSquareDistanceToCenter) {\n            minSquareDistanceToCenter = d2;\n            closestPixelIndex = i;\n          }\n        }\n        i += 4;\n      }\n    }\n  }\n\n  if (closestPixelIndex >= 0) {\n    // Decode picked object index from color\n    const pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;\n    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n    const pickedLayer = layers[pickedLayerIndex];\n    if (pickedLayer) {\n      const pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);\n      return {pickedColor, pickedLayer, pickedObjectIndex};\n    }\n    log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n  }\n\n  return NO_PICKED_OBJECT;\n}\n/* eslint-enable max-depth, max-statements */\n\n/**\n * Examines a picking buffer for unique colors\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\nfunction getUniquesFromPickingBuffer(gl, {pickedColors, layers}) {\n  const uniqueColors = new Map();\n\n  // Traverse all pixels in picking results and get unique colors\n  if (pickedColors) {\n    for (let i = 0; i < pickedColors.length; i += 4) {\n      // Decode picked layer from color\n      const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        const pickedColor = pickedColors.slice(i, i + 4);\n        const colorKey = pickedColor.join(',');\n        // eslint-disable-next-line\n        if (!uniqueColors.has(colorKey)) {\n          const pickedLayer = layers[pickedLayerIndex];\n          // eslint-disable-next-line\n          if (pickedLayer) {\n            uniqueColors.set(colorKey, {\n              pickedColor,\n              pickedLayer,\n              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}\n\n// Walk up the layer composite chain to populate the info object\nfunction getLayerPickingInfo({layer, info, mode}) {\n  while (layer && info) {\n    // For a composite layer, sourceLayer will point to the sublayer\n    // where the event originates from.\n    // It provides additional context for the composite layer's\n    // getPickingInfo() method to populate the info object\n    const sourceLayer = info.layer || layer;\n    info.layer = layer;\n    // layer.pickLayer() function requires a non-null ```layer.state```\n    // object to funtion properly. So the layer refereced here\n    // must be the \"current\" layer, not an \"out-dated\" / \"invalidated\" layer\n    info = layer.pickLayer({info, mode, sourceLayer});\n    layer = layer.parentLayer;\n  }\n  return info;\n}\n"],"file":"pick-layers.js"}