"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _autobind = _interopRequireDefault(require("./utils/autobind"));

var _inheritsFrom = require("./utils/inherits-from");

var _core = require("@deck.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var log = _core.experimental.log;
var propTypes = Object.assign({}, _core.Deck.getPropTypes(_propTypes.default), {
  viewports: _propTypes.default.array,
  // Deprecated
  viewport: _propTypes.default.object // Deprecated

});
var defaultProps = _core.Deck.defaultProps;

var DeckGL =
/*#__PURE__*/
function (_React$Component) {
  _inherits(DeckGL, _React$Component);

  function DeckGL(props) {
    var _this;

    _classCallCheck(this, DeckGL);

    _this = _possibleConstructorReturn(this, (DeckGL.__proto__ || Object.getPrototypeOf(DeckGL)).call(this, props));
    _this.state = {};
    _this.children = [];
    (0, _autobind.default)(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(DeckGL, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.deck = new _core.Deck(Object.assign({}, this.props, {
        canvas: this.deckCanvas,
        onResize: function onResize(size) {
          return _this2.forceUpdate();
        }
      }));

      this._updateFromProps(this.props);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      this._updateFromProps(nextProps);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.deck.finalize();
    } // Public API

  }, {
    key: "pickObject",
    value: function pickObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          _ref$radius = _ref.radius,
          radius = _ref$radius === void 0 ? 0 : _ref$radius,
          _ref$layerIds = _ref.layerIds,
          layerIds = _ref$layerIds === void 0 ? null : _ref$layerIds;
      return this.deck.pickObject({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds
      });
    }
  }, {
    key: "pickObjects",
    value: function pickObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$width = _ref2.width,
          width = _ref2$width === void 0 ? 1 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === void 0 ? 1 : _ref2$height,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds;
      return this.deck.pickObjects({
        x: x,
        y: y,
        width: width,
        height: height,
        layerIds: layerIds
      });
    }
  }, {
    key: "queryObject",
    value: function queryObject(opts) {
      log.deprecated('queryObject', 'pickObject')();
      return this.deck.pickObject(opts);
    }
  }, {
    key: "queryVisibleObjects",
    value: function queryVisibleObjects(opts) {
      log.deprecated('queryVisibleObjects', 'pickObjects')();
      return this.pickObjects(opts);
    } // Private Helpers
    // 1. Extract any JSX layers from the react children
    // 2. Handle any backwards compatiblity props for React layer
    // Needs to be called both from initial mount, and when new props arrive

  }, {
    key: "_updateFromProps",
    value: function _updateFromProps(nextProps) {
      // Support old "geospatial view state as separate props" style (React only!)
      var viewState = nextProps.viewState;

      if (!viewState) {
        var latitude = nextProps.latitude,
            longitude = nextProps.longitude,
            zoom = nextProps.zoom,
            pitch = nextProps.pitch,
            bearing = nextProps.bearing;
        viewState = nextProps.viewState || {
          latitude: latitude,
          longitude: longitude,
          zoom: zoom,
          pitch: pitch,
          bearing: bearing
        };
      } // Support old `viewports` prop (React only!)


      var views = nextProps.views || nextProps.viewports || nextProps.viewport && [nextProps.viewport];

      if (nextProps.viewports) {
        log.deprecated('DeckGL.viewports', 'DeckGL.views')();
      }

      if (nextProps.viewport) {
        log.deprecated('DeckGL.viewport', 'DeckGL.views')();
      } // extract any deck.gl layers masquerading as react elements from props.children


      var _extractJSXLayers2 = this._extractJSXLayers(nextProps.children),
          layers = _extractJSXLayers2.layers,
          children = _extractJSXLayers2.children;

      if (this.deck) {
        this.deck.setProps(Object.assign({}, nextProps, {
          views: views,
          viewState: viewState,
          // Avoid modifying layers array if no JSX layers were found
          layers: layers ? _toConsumableArray(layers).concat(_toConsumableArray(nextProps.layers)) : nextProps.layers
        }));
      }

      this.children = children;
    } // extracts any deck.gl layers masquerading as react elements from props.children

  }, {
    key: "_extractJSXLayers",
    value: function _extractJSXLayers(children) {
      var reactChildren = []; // extract real react elements (i.e. not deck.gl layers)

      var layers = null; // extracted layer from react children, will add to deck.gl layer array

      _react.default.Children.forEach(children, function (reactElement) {
        if (reactElement) {
          // For some reason Children.forEach doesn't filter out `null`s
          var LayerType = reactElement.type;

          if ((0, _inheritsFrom.inheritsFrom)(LayerType, _core.Layer)) {
            var layer = new LayerType(reactElement.props);
            layers = layers || [];
            layers.push(layer);
          } else {
            reactChildren.push(reactElement);
          }
        }
      });

      return {
        layers: layers,
        children: reactChildren
      };
    } // Iterate over views and reposition children associated with views
    // TODO - Can we supply a similar function for the non-React case?

  }, {
    key: "_renderChildrenUnderViews",
    value: function _renderChildrenUnderViews(children) {
      var _this3 = this;

      // Flatten out nested views array
      var views = this.deck ? this.deck.getViewports() : []; // Build a view id to view index

      var viewMap = {};
      views.forEach(function (view) {
        if (view.id) {
          viewMap[view.id] = view;
        }
      });
      return children.map( // If child specifies props.viewId, position under view, otherwise render as normal
      function (child, i) {
        return child.props.viewId || child.props.viewId ? _this3._positionChild({
          child: child,
          viewMap: viewMap,
          i: i
        }) : child;
      });
    }
  }, {
    key: "_positionChild",
    value: function _positionChild(_ref3) {
      var child = _ref3.child,
          viewMap = _ref3.viewMap,
          i = _ref3.i;
      var _child$props = child.props,
          viewId = _child$props.viewId,
          viewportId = _child$props.viewportId;

      if (viewportId) {
        log.deprecated('viewportId', 'viewId')();
      }

      var view = viewMap[viewId || viewportId]; // Drop (auto-hide) elements with viewId that are not matched by any current view

      if (!view) {
        return null;
      } // Resolve potentially relative dimensions using the deck.gl container size


      var x = view.x,
          y = view.y,
          width = view.width,
          height = view.height; // Clone the element with width and height set per view

      var newProps = Object.assign({}, child.props, {
        width: width,
        height: height
      }); // Inject map properties
      // TODO - this is too react-map-gl specific

      Object.assign(newProps, view.getMercatorParams(), {
        visible: view.isMapSynched()
      });
      var clone = (0, _react.cloneElement)(child, newProps); // Wrap it in an absolutely positioning div

      var style = {
        position: 'absolute',
        left: x,
        top: y,
        width: width,
        height: height
      };
      var key = "view-child-".concat(viewId, "-").concat(i);
      return (0, _react.createElement)('div', {
        key: key,
        id: key,
        style: style
      }, clone);
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      // Render the background elements (typically react-map-gl instances)
      // using the view descriptors
      var children = this._renderChildrenUnderViews(this.children); // Note that width and height are handled by deck.gl


      var id = this.props.id; // TODO - this styling is enforced for correct positioning with children
      // It can override the styling set by `Deck`, this should be consolidated.

      var style = Object.assign({}, {
        position: 'absolute',
        left: 0,
        top: 0
      }, this.props.style);
      var canvas = (0, _react.createElement)('canvas', {
        ref: function ref(c) {
          return _this4.deckCanvas = c;
        },
        key: 'deck-canvas',
        id: id,
        style: style
      }); // Render deck.gl as last child

      children.push(canvas);
      return (0, _react.createElement)('div', {
        id: 'deckgl-wrapper'
      }, children);
    }
  }]);

  return DeckGL;
}(_react.default.Component);

exports.default = DeckGL;
DeckGL.propTypes = propTypes;
DeckGL.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kZWNrZ2wuanMiXSwibmFtZXMiOlsibG9nIiwiZXhwZXJpbWVudGFsIiwicHJvcFR5cGVzIiwiT2JqZWN0IiwiYXNzaWduIiwiRGVjayIsImdldFByb3BUeXBlcyIsIlByb3BUeXBlcyIsInZpZXdwb3J0cyIsImFycmF5Iiwidmlld3BvcnQiLCJvYmplY3QiLCJkZWZhdWx0UHJvcHMiLCJEZWNrR0wiLCJwcm9wcyIsInN0YXRlIiwiY2hpbGRyZW4iLCJkZWNrIiwiY2FudmFzIiwiZGVja0NhbnZhcyIsIm9uUmVzaXplIiwiZm9yY2VVcGRhdGUiLCJfdXBkYXRlRnJvbVByb3BzIiwibmV4dFByb3BzIiwiZmluYWxpemUiLCJ4IiwieSIsInJhZGl1cyIsImxheWVySWRzIiwicGlja09iamVjdCIsIndpZHRoIiwiaGVpZ2h0IiwicGlja09iamVjdHMiLCJvcHRzIiwiZGVwcmVjYXRlZCIsInZpZXdTdGF0ZSIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInBpdGNoIiwiYmVhcmluZyIsInZpZXdzIiwiX2V4dHJhY3RKU1hMYXllcnMiLCJsYXllcnMiLCJzZXRQcm9wcyIsInJlYWN0Q2hpbGRyZW4iLCJSZWFjdCIsIkNoaWxkcmVuIiwiZm9yRWFjaCIsInJlYWN0RWxlbWVudCIsIkxheWVyVHlwZSIsInR5cGUiLCJMYXllciIsImxheWVyIiwicHVzaCIsImdldFZpZXdwb3J0cyIsInZpZXdNYXAiLCJ2aWV3IiwiaWQiLCJtYXAiLCJjaGlsZCIsImkiLCJ2aWV3SWQiLCJfcG9zaXRpb25DaGlsZCIsInZpZXdwb3J0SWQiLCJuZXdQcm9wcyIsImdldE1lcmNhdG9yUGFyYW1zIiwidmlzaWJsZSIsImlzTWFwU3luY2hlZCIsImNsb25lIiwic3R5bGUiLCJwb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJrZXkiLCJfcmVuZGVyQ2hpbGRyZW5VbmRlclZpZXdzIiwicmVmIiwiYyIsIkNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQW9CQTs7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NSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgUmVhY3QsIHtjcmVhdGVFbGVtZW50LCBjbG9uZUVsZW1lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnLi91dGlscy9hdXRvYmluZCc7XG5pbXBvcnQge2luaGVyaXRzRnJvbX0gZnJvbSAnLi91dGlscy9pbmhlcml0cy1mcm9tJztcbmltcG9ydCB7RGVjaywgTGF5ZXIsIGV4cGVyaW1lbnRhbH0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5jb25zdCB7bG9nfSA9IGV4cGVyaW1lbnRhbDtcblxuY29uc3QgcHJvcFR5cGVzID0gT2JqZWN0LmFzc2lnbih7fSwgRGVjay5nZXRQcm9wVHlwZXMoUHJvcFR5cGVzKSwge1xuICB2aWV3cG9ydHM6IFByb3BUeXBlcy5hcnJheSwgLy8gRGVwcmVjYXRlZFxuICB2aWV3cG9ydDogUHJvcFR5cGVzLm9iamVjdCAvLyBEZXByZWNhdGVkXG59KTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0gRGVjay5kZWZhdWx0UHJvcHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlY2tHTCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmRlY2sgPSBuZXcgRGVjayhcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgY2FudmFzOiB0aGlzLmRlY2tDYW52YXMsXG4gICAgICAgIG9uUmVzaXplOiBzaXplID0+IHRoaXMuZm9yY2VVcGRhdGUoKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuX3VwZGF0ZUZyb21Qcm9wcyh0aGlzLnByb3BzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdGhpcy5fdXBkYXRlRnJvbVByb3BzKG5leHRQcm9wcyk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmRlY2suZmluYWxpemUoKTtcbiAgfVxuXG4gIC8vIFB1YmxpYyBBUElcblxuICBwaWNrT2JqZWN0KHt4LCB5LCByYWRpdXMgPSAwLCBsYXllcklkcyA9IG51bGx9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjay5waWNrT2JqZWN0KHt4LCB5LCByYWRpdXMsIGxheWVySWRzfSk7XG4gIH1cblxuICBwaWNrT2JqZWN0cyh7eCwgeSwgd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBsYXllcklkcyA9IG51bGx9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjay5waWNrT2JqZWN0cyh7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGF5ZXJJZHN9KTtcbiAgfVxuXG4gIHF1ZXJ5T2JqZWN0KG9wdHMpIHtcbiAgICBsb2cuZGVwcmVjYXRlZCgncXVlcnlPYmplY3QnLCAncGlja09iamVjdCcpKCk7XG4gICAgcmV0dXJuIHRoaXMuZGVjay5waWNrT2JqZWN0KG9wdHMpO1xuICB9XG5cbiAgcXVlcnlWaXNpYmxlT2JqZWN0cyhvcHRzKSB7XG4gICAgbG9nLmRlcHJlY2F0ZWQoJ3F1ZXJ5VmlzaWJsZU9iamVjdHMnLCAncGlja09iamVjdHMnKSgpO1xuICAgIHJldHVybiB0aGlzLnBpY2tPYmplY3RzKG9wdHMpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZSBIZWxwZXJzXG5cbiAgLy8gMS4gRXh0cmFjdCBhbnkgSlNYIGxheWVycyBmcm9tIHRoZSByZWFjdCBjaGlsZHJlblxuICAvLyAyLiBIYW5kbGUgYW55IGJhY2t3YXJkcyBjb21wYXRpYmxpdHkgcHJvcHMgZm9yIFJlYWN0IGxheWVyXG4gIC8vIE5lZWRzIHRvIGJlIGNhbGxlZCBib3RoIGZyb20gaW5pdGlhbCBtb3VudCwgYW5kIHdoZW4gbmV3IHByb3BzIGFycml2ZVxuICBfdXBkYXRlRnJvbVByb3BzKG5leHRQcm9wcykge1xuICAgIC8vIFN1cHBvcnQgb2xkIFwiZ2Vvc3BhdGlhbCB2aWV3IHN0YXRlIGFzIHNlcGFyYXRlIHByb3BzXCIgc3R5bGUgKFJlYWN0IG9ubHkhKVxuICAgIGxldCB7dmlld1N0YXRlfSA9IG5leHRQcm9wcztcbiAgICBpZiAoIXZpZXdTdGF0ZSkge1xuICAgICAgY29uc3Qge2xhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20sIHBpdGNoLCBiZWFyaW5nfSA9IG5leHRQcm9wcztcbiAgICAgIHZpZXdTdGF0ZSA9IG5leHRQcm9wcy52aWV3U3RhdGUgfHwge2xhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20sIHBpdGNoLCBiZWFyaW5nfTtcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IG9sZCBgdmlld3BvcnRzYCBwcm9wIChSZWFjdCBvbmx5ISlcbiAgICBjb25zdCB2aWV3cyA9XG4gICAgICBuZXh0UHJvcHMudmlld3MgfHwgbmV4dFByb3BzLnZpZXdwb3J0cyB8fCAobmV4dFByb3BzLnZpZXdwb3J0ICYmIFtuZXh0UHJvcHMudmlld3BvcnRdKTtcbiAgICBpZiAobmV4dFByb3BzLnZpZXdwb3J0cykge1xuICAgICAgbG9nLmRlcHJlY2F0ZWQoJ0RlY2tHTC52aWV3cG9ydHMnLCAnRGVja0dMLnZpZXdzJykoKTtcbiAgICB9XG4gICAgaWYgKG5leHRQcm9wcy52aWV3cG9ydCkge1xuICAgICAgbG9nLmRlcHJlY2F0ZWQoJ0RlY2tHTC52aWV3cG9ydCcsICdEZWNrR0wudmlld3MnKSgpO1xuICAgIH1cblxuICAgIC8vIGV4dHJhY3QgYW55IGRlY2suZ2wgbGF5ZXJzIG1hc3F1ZXJhZGluZyBhcyByZWFjdCBlbGVtZW50cyBmcm9tIHByb3BzLmNoaWxkcmVuXG4gICAgY29uc3Qge2xheWVycywgY2hpbGRyZW59ID0gdGhpcy5fZXh0cmFjdEpTWExheWVycyhuZXh0UHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKHRoaXMuZGVjaykge1xuICAgICAgdGhpcy5kZWNrLnNldFByb3BzKFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBuZXh0UHJvcHMsIHtcbiAgICAgICAgICB2aWV3cyxcbiAgICAgICAgICB2aWV3U3RhdGUsXG4gICAgICAgICAgLy8gQXZvaWQgbW9kaWZ5aW5nIGxheWVycyBhcnJheSBpZiBubyBKU1ggbGF5ZXJzIHdlcmUgZm91bmRcbiAgICAgICAgICBsYXllcnM6IGxheWVycyA/IFsuLi5sYXllcnMsIC4uLm5leHRQcm9wcy5sYXllcnNdIDogbmV4dFByb3BzLmxheWVyc1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH1cblxuICAvLyBleHRyYWN0cyBhbnkgZGVjay5nbCBsYXllcnMgbWFzcXVlcmFkaW5nIGFzIHJlYWN0IGVsZW1lbnRzIGZyb20gcHJvcHMuY2hpbGRyZW5cbiAgX2V4dHJhY3RKU1hMYXllcnMoY2hpbGRyZW4pIHtcbiAgICBjb25zdCByZWFjdENoaWxkcmVuID0gW107IC8vIGV4dHJhY3QgcmVhbCByZWFjdCBlbGVtZW50cyAoaS5lLiBub3QgZGVjay5nbCBsYXllcnMpXG4gICAgbGV0IGxheWVycyA9IG51bGw7IC8vIGV4dHJhY3RlZCBsYXllciBmcm9tIHJlYWN0IGNoaWxkcmVuLCB3aWxsIGFkZCB0byBkZWNrLmdsIGxheWVyIGFycmF5XG5cbiAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCByZWFjdEVsZW1lbnQgPT4ge1xuICAgICAgaWYgKHJlYWN0RWxlbWVudCkge1xuICAgICAgICAvLyBGb3Igc29tZSByZWFzb24gQ2hpbGRyZW4uZm9yRWFjaCBkb2Vzbid0IGZpbHRlciBvdXQgYG51bGxgc1xuICAgICAgICBjb25zdCBMYXllclR5cGUgPSByZWFjdEVsZW1lbnQudHlwZTtcbiAgICAgICAgaWYgKGluaGVyaXRzRnJvbShMYXllclR5cGUsIExheWVyKSkge1xuICAgICAgICAgIGNvbnN0IGxheWVyID0gbmV3IExheWVyVHlwZShyZWFjdEVsZW1lbnQucHJvcHMpO1xuICAgICAgICAgIGxheWVycyA9IGxheWVycyB8fCBbXTtcbiAgICAgICAgICBsYXllcnMucHVzaChsYXllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVhY3RDaGlsZHJlbi5wdXNoKHJlYWN0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7bGF5ZXJzLCBjaGlsZHJlbjogcmVhY3RDaGlsZHJlbn07XG4gIH1cblxuICAvLyBJdGVyYXRlIG92ZXIgdmlld3MgYW5kIHJlcG9zaXRpb24gY2hpbGRyZW4gYXNzb2NpYXRlZCB3aXRoIHZpZXdzXG4gIC8vIFRPRE8gLSBDYW4gd2Ugc3VwcGx5IGEgc2ltaWxhciBmdW5jdGlvbiBmb3IgdGhlIG5vbi1SZWFjdCBjYXNlP1xuICBfcmVuZGVyQ2hpbGRyZW5VbmRlclZpZXdzKGNoaWxkcmVuKSB7XG4gICAgLy8gRmxhdHRlbiBvdXQgbmVzdGVkIHZpZXdzIGFycmF5XG4gICAgY29uc3Qgdmlld3MgPSB0aGlzLmRlY2sgPyB0aGlzLmRlY2suZ2V0Vmlld3BvcnRzKCkgOiBbXTtcblxuICAgIC8vIEJ1aWxkIGEgdmlldyBpZCB0byB2aWV3IGluZGV4XG4gICAgY29uc3Qgdmlld01hcCA9IHt9O1xuICAgIHZpZXdzLmZvckVhY2godmlldyA9PiB7XG4gICAgICBpZiAodmlldy5pZCkge1xuICAgICAgICB2aWV3TWFwW3ZpZXcuaWRdID0gdmlldztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjaGlsZHJlbi5tYXAoXG4gICAgICAvLyBJZiBjaGlsZCBzcGVjaWZpZXMgcHJvcHMudmlld0lkLCBwb3NpdGlvbiB1bmRlciB2aWV3LCBvdGhlcndpc2UgcmVuZGVyIGFzIG5vcm1hbFxuICAgICAgKGNoaWxkLCBpKSA9PlxuICAgICAgICBjaGlsZC5wcm9wcy52aWV3SWQgfHwgY2hpbGQucHJvcHMudmlld0lkID8gdGhpcy5fcG9zaXRpb25DaGlsZCh7Y2hpbGQsIHZpZXdNYXAsIGl9KSA6IGNoaWxkXG4gICAgKTtcbiAgfVxuXG4gIF9wb3NpdGlvbkNoaWxkKHtjaGlsZCwgdmlld01hcCwgaX0pIHtcbiAgICBjb25zdCB7dmlld0lkLCB2aWV3cG9ydElkfSA9IGNoaWxkLnByb3BzO1xuICAgIGlmICh2aWV3cG9ydElkKSB7XG4gICAgICBsb2cuZGVwcmVjYXRlZCgndmlld3BvcnRJZCcsICd2aWV3SWQnKSgpO1xuICAgIH1cbiAgICBjb25zdCB2aWV3ID0gdmlld01hcFt2aWV3SWQgfHwgdmlld3BvcnRJZF07XG5cbiAgICAvLyBEcm9wIChhdXRvLWhpZGUpIGVsZW1lbnRzIHdpdGggdmlld0lkIHRoYXQgYXJlIG5vdCBtYXRjaGVkIGJ5IGFueSBjdXJyZW50IHZpZXdcbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFJlc29sdmUgcG90ZW50aWFsbHkgcmVsYXRpdmUgZGltZW5zaW9ucyB1c2luZyB0aGUgZGVjay5nbCBjb250YWluZXIgc2l6ZVxuICAgIGNvbnN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSA9IHZpZXc7XG5cbiAgICAvLyBDbG9uZSB0aGUgZWxlbWVudCB3aXRoIHdpZHRoIGFuZCBoZWlnaHQgc2V0IHBlciB2aWV3XG4gICAgY29uc3QgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBjaGlsZC5wcm9wcywge3dpZHRoLCBoZWlnaHR9KTtcblxuICAgIC8vIEluamVjdCBtYXAgcHJvcGVydGllc1xuICAgIC8vIFRPRE8gLSB0aGlzIGlzIHRvbyByZWFjdC1tYXAtZ2wgc3BlY2lmaWNcbiAgICBPYmplY3QuYXNzaWduKG5ld1Byb3BzLCB2aWV3LmdldE1lcmNhdG9yUGFyYW1zKCksIHtcbiAgICAgIHZpc2libGU6IHZpZXcuaXNNYXBTeW5jaGVkKClcbiAgICB9KTtcblxuICAgIGNvbnN0IGNsb25lID0gY2xvbmVFbGVtZW50KGNoaWxkLCBuZXdQcm9wcyk7XG5cbiAgICAvLyBXcmFwIGl0IGluIGFuIGFic29sdXRlbHkgcG9zaXRpb25pbmcgZGl2XG4gICAgY29uc3Qgc3R5bGUgPSB7cG9zaXRpb246ICdhYnNvbHV0ZScsIGxlZnQ6IHgsIHRvcDogeSwgd2lkdGgsIGhlaWdodH07XG4gICAgY29uc3Qga2V5ID0gYHZpZXctY2hpbGQtJHt2aWV3SWR9LSR7aX1gO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7a2V5LCBpZDoga2V5LCBzdHlsZX0sIGNsb25lKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICAvLyBSZW5kZXIgdGhlIGJhY2tncm91bmQgZWxlbWVudHMgKHR5cGljYWxseSByZWFjdC1tYXAtZ2wgaW5zdGFuY2VzKVxuICAgIC8vIHVzaW5nIHRoZSB2aWV3IGRlc2NyaXB0b3JzXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJDaGlsZHJlblVuZGVyVmlld3ModGhpcy5jaGlsZHJlbik7XG5cbiAgICAvLyBOb3RlIHRoYXQgd2lkdGggYW5kIGhlaWdodCBhcmUgaGFuZGxlZCBieSBkZWNrLmdsXG4gICAgY29uc3Qge2lkfSA9IHRoaXMucHJvcHM7XG4gICAgLy8gVE9ETyAtIHRoaXMgc3R5bGluZyBpcyBlbmZvcmNlZCBmb3IgY29ycmVjdCBwb3NpdGlvbmluZyB3aXRoIGNoaWxkcmVuXG4gICAgLy8gSXQgY2FuIG92ZXJyaWRlIHRoZSBzdHlsaW5nIHNldCBieSBgRGVja2AsIHRoaXMgc2hvdWxkIGJlIGNvbnNvbGlkYXRlZC5cbiAgICBjb25zdCBzdHlsZSA9IE9iamVjdC5hc3NpZ24oe30sIHtwb3NpdGlvbjogJ2Fic29sdXRlJywgbGVmdDogMCwgdG9wOiAwfSwgdGhpcy5wcm9wcy5zdHlsZSk7XG5cbiAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVFbGVtZW50KCdjYW52YXMnLCB7XG4gICAgICByZWY6IGMgPT4gKHRoaXMuZGVja0NhbnZhcyA9IGMpLFxuICAgICAga2V5OiAnZGVjay1jYW52YXMnLFxuICAgICAgaWQsXG4gICAgICBzdHlsZVxuICAgIH0pO1xuXG4gICAgLy8gUmVuZGVyIGRlY2suZ2wgYXMgbGFzdCBjaGlsZFxuICAgIGNoaWxkcmVuLnB1c2goY2FudmFzKTtcblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7aWQ6ICdkZWNrZ2wtd3JhcHBlcid9LCBjaGlsZHJlbik7XG4gIH1cbn1cblxuRGVja0dMLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkRlY2tHTC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=