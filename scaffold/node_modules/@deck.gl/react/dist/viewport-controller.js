"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = require("react");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _mjolnir = require("mjolnir.js");

var _core = require("@deck.gl/core");

var _cursors = _interopRequireDefault(require("./utils/cursors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ViewportControls = _core.experimental.ViewportControls,
    TransitionManager = _core.experimental.TransitionManager;
var propTypes = {
  viewportState: _propTypes.default.func,
  state: _propTypes.default.object,

  /** Viewport props */

  /** The width of the map. */
  width: _propTypes.default.number.isRequired,

  /** The height of the map. */
  height: _propTypes.default.number.isRequired,

  /** The longitude of the center of the map. */
  longitude: _propTypes.default.number.isRequired,

  /** The latitude of the center of the map. */
  latitude: _propTypes.default.number.isRequired,

  /** The tile zoom level of the map. */
  zoom: _propTypes.default.number.isRequired,

  /** Specify the bearing of the viewport */
  bearing: _propTypes.default.number,

  /** Specify the pitch of the viewport */
  pitch: _propTypes.default.number,

  /** Altitude of the viewport camera. Default 1.5 "screen heights" */
  // Note: Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
  altitude: _propTypes.default.number,
  // Camera position for FirstPersonViewport
  position: _propTypes.default.array,

  /** Viewport constraints */
  // Max zoom level
  maxZoom: _propTypes.default.number,
  // Min zoom level
  minZoom: _propTypes.default.number,
  // Max pitch in degrees
  maxPitch: _propTypes.default.number,
  // Min pitch in degrees
  minPitch: _propTypes.default.number,

  /**
   * `onViewportChange` callback is fired when the user interacted with the
   * map. The object passed to the callback contains viewport properties
   * such as `longitude`, `latitude`, `zoom` etc.
   */
  onViewportChange: _propTypes.default.func,

  /** Viewport transition **/
  // transition duration for viewport change
  transitionDuration: _propTypes.default.number,
  // an instance of ViewportTransitionInterpolator, can be used to perform custom transitions.
  transitionInterpolator: _propTypes.default.object,
  // type of interruption of current transition on update.
  transitionInterruption: _propTypes.default.number,
  // easing function
  transitionEasing: _propTypes.default.func,
  // transition status update functions
  onTransitionStart: _propTypes.default.func,
  onTransitionInterrupt: _propTypes.default.func,
  onTransitionEnd: _propTypes.default.func,

  /** Enables control event handling */
  // Scroll to zoom
  scrollZoom: _propTypes.default.bool,
  // Drag to pan
  dragPan: _propTypes.default.bool,
  // Drag to rotate
  dragRotate: _propTypes.default.bool,
  // Double click to zoom
  doubleClickZoom: _propTypes.default.bool,
  // Pinch to zoom / rotate
  touchZoomRotate: _propTypes.default.bool,

  /** Accessor that returns a cursor style to show interactive state */
  getCursor: _propTypes.default.func,
  // A map control instance to replace the default map controls
  // The object must expose one property: `events` as an array of subscribed
  // event names; and two methods: `setState(state)` and `handle(event)`
  controls: _propTypes.default.shape({
    events: _propTypes.default.arrayOf(_propTypes.default.string),
    handleEvent: _propTypes.default.func
  })
};

var getDefaultCursor = function getDefaultCursor(_ref) {
  var isDragging = _ref.isDragging;
  return isDragging ? _cursors.default.GRABBING : _cursors.default.GRAB;
};

var defaultProps = Object.assign({}, TransitionManager.defaultProps, {
  onViewportChange: null,
  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,
  touchZoomRotate: true,
  getCursor: getDefaultCursor
});

var ViewportController =
/*#__PURE__*/
function (_Component) {
  _inherits(ViewportController, _Component);

  function ViewportController(props) {
    var _this;

    _classCallCheck(this, ViewportController);

    _this = _possibleConstructorReturn(this, (ViewportController.__proto__ || Object.getPrototypeOf(ViewportController)).call(this, props));
    _this.state = {
      isDragging: false // Whether the cursor is down

    };
    return _this;
  }

  _createClass(ViewportController, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._eventManager = new _mjolnir.EventManager(this.eventCanvas); // If props.controls is not provided, fallback to default MapControls instance
      // Cannot use defaultProps here because it needs to be per map instance

      this._controls = this.props.controls || new ViewportControls(this.props.viewportState);

      this._controls.setOptions(Object.assign({}, this.props, {
        onStateChange: this._onInteractiveStateChange.bind(this),
        eventManager: this._eventManager
      }));

      this._transitionManger = new TransitionManager(this.props);
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (this._transitionManger) {
        var transitionTriggered = this._transitionManger.processViewportChange(nextProps); // Skip this render to avoid jump during viewport transitions.


        return !transitionTriggered;
      }

      return true;
    }
  }, {
    key: "componentWillUpdate",
    value: function componentWillUpdate(nextProps) {
      if (this._controls) {
        this._controls.setOptions(nextProps);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._eventManager.destroy();
    }
  }, {
    key: "_onInteractiveStateChange",
    value: function _onInteractiveStateChange(_ref2) {
      var _ref2$isDragging = _ref2.isDragging,
          isDragging = _ref2$isDragging === void 0 ? false : _ref2$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.setState({
          isDragging: isDragging
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          width = _props.width,
          height = _props.height,
          getCursor = _props.getCursor;
      var eventCanvasStyle = {
        width: width,
        height: height,
        position: 'relative',
        cursor: getCursor(this.state)
      };
      return (0, _react.createElement)('div', {
        key: 'map-controls',
        ref: function ref(c) {
          return _this2.eventCanvas = c;
        },
        style: eventCanvasStyle
      }, this.props.children);
    }
  }]);

  return ViewportController;
}(_react.Component);

exports.default = ViewportController;
ViewportController.displayName = 'ViewportController';
ViewportController.propTypes = propTypes;
ViewportController.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy92aWV3cG9ydC1jb250cm9sbGVyLmpzIl0sIm5hbWVzIjpbIlZpZXdwb3J0Q29udHJvbHMiLCJleHBlcmltZW50YWwiLCJUcmFuc2l0aW9uTWFuYWdlciIsInByb3BUeXBlcyIsInZpZXdwb3J0U3RhdGUiLCJQcm9wVHlwZXMiLCJmdW5jIiwic3RhdGUiLCJvYmplY3QiLCJ3aWR0aCIsIm51bWJlciIsImlzUmVxdWlyZWQiLCJoZWlnaHQiLCJsb25naXR1ZGUiLCJsYXRpdHVkZSIsInpvb20iLCJiZWFyaW5nIiwicGl0Y2giLCJhbHRpdHVkZSIsInBvc2l0aW9uIiwiYXJyYXkiLCJtYXhab29tIiwibWluWm9vbSIsIm1heFBpdGNoIiwibWluUGl0Y2giLCJvblZpZXdwb3J0Q2hhbmdlIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvbkludGVycG9sYXRvciIsInRyYW5zaXRpb25JbnRlcnJ1cHRpb24iLCJ0cmFuc2l0aW9uRWFzaW5nIiwib25UcmFuc2l0aW9uU3RhcnQiLCJvblRyYW5zaXRpb25JbnRlcnJ1cHQiLCJvblRyYW5zaXRpb25FbmQiLCJzY3JvbGxab29tIiwiYm9vbCIsImRyYWdQYW4iLCJkcmFnUm90YXRlIiwiZG91YmxlQ2xpY2tab29tIiwidG91Y2hab29tUm90YXRlIiwiZ2V0Q3Vyc29yIiwiY29udHJvbHMiLCJzaGFwZSIsImV2ZW50cyIsImFycmF5T2YiLCJzdHJpbmciLCJoYW5kbGVFdmVudCIsImdldERlZmF1bHRDdXJzb3IiLCJpc0RyYWdnaW5nIiwiQ1VSU09SIiwiR1JBQkJJTkciLCJHUkFCIiwiZGVmYXVsdFByb3BzIiwiT2JqZWN0IiwiYXNzaWduIiwiVmlld3BvcnRDb250cm9sbGVyIiwicHJvcHMiLCJfZXZlbnRNYW5hZ2VyIiwiRXZlbnRNYW5hZ2VyIiwiZXZlbnRDYW52YXMiLCJfY29udHJvbHMiLCJzZXRPcHRpb25zIiwib25TdGF0ZUNoYW5nZSIsIl9vbkludGVyYWN0aXZlU3RhdGVDaGFuZ2UiLCJiaW5kIiwiZXZlbnRNYW5hZ2VyIiwiX3RyYW5zaXRpb25NYW5nZXIiLCJuZXh0UHJvcHMiLCJuZXh0U3RhdGUiLCJ0cmFuc2l0aW9uVHJpZ2dlcmVkIiwicHJvY2Vzc1ZpZXdwb3J0Q2hhbmdlIiwiZGVzdHJveSIsInNldFN0YXRlIiwiZXZlbnRDYW52YXNTdHlsZSIsImN1cnNvciIsImtleSIsInJlZiIsImMiLCJzdHlsZSIsImNoaWxkcmVuIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFGT0EsZ0IsR0FBdUNDLGtCLENBQXZDRCxnQjtJQUFrQkUsaUIsR0FBcUJELGtCLENBQXJCQyxpQjtBQUl6QixJQUFNQyxZQUFZO0FBQ2hCQyxpQkFBZUMsbUJBQVVDLElBRFQ7QUFFaEJDLFNBQU9GLG1CQUFVRyxNQUZEOztBQUloQjs7QUFDQTtBQUNBQyxTQUFPSixtQkFBVUssTUFBVixDQUFpQkMsVUFOUjs7QUFPaEI7QUFDQUMsVUFBUVAsbUJBQVVLLE1BQVYsQ0FBaUJDLFVBUlQ7O0FBU2hCO0FBQ0FFLGFBQVdSLG1CQUFVSyxNQUFWLENBQWlCQyxVQVZaOztBQVdoQjtBQUNBRyxZQUFVVCxtQkFBVUssTUFBVixDQUFpQkMsVUFaWDs7QUFhaEI7QUFDQUksUUFBTVYsbUJBQVVLLE1BQVYsQ0FBaUJDLFVBZFA7O0FBZWhCO0FBQ0FLLFdBQVNYLG1CQUFVSyxNQWhCSDs7QUFpQmhCO0FBQ0FPLFNBQU9aLG1CQUFVSyxNQWxCRDs7QUFtQmhCO0FBQ0E7QUFDQVEsWUFBVWIsbUJBQVVLLE1BckJKO0FBc0JoQjtBQUNBUyxZQUFVZCxtQkFBVWUsS0F2Qko7O0FBeUJoQjtBQUNBO0FBQ0FDLFdBQVNoQixtQkFBVUssTUEzQkg7QUE0QmhCO0FBQ0FZLFdBQVNqQixtQkFBVUssTUE3Qkg7QUE4QmhCO0FBQ0FhLFlBQVVsQixtQkFBVUssTUEvQko7QUFnQ2hCO0FBQ0FjLFlBQVVuQixt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QUtBLFNBQUwsQ0FBZUMsVUFBZixDQUEwQk0sU0FBMUI7QUFDRDtBQUNGOzs7MkNBRXNCO0FBQ3JCLFdBQUtWLGFBQUwsQ0FBbUJjLE9BQW5CO0FBQ0Q7OztxREFFK0M7QUFBQSxtQ0FBckJ2QixVQUFxQjtBQUFBLFVBQXJCQSxVQUFxQixpQ0FBUixLQUFROztBQUM5QyxVQUFJQSxlQUFlLEtBQUt4QyxLQUFMLENBQVd3QyxVQUE5QixFQUEwQztBQUN4QyxhQUFLd0IsUUFBTCxDQUFjO0FBQUN4QjtBQUFELFNBQWQ7QUFDRDtBQUNGOzs7NkJBRVE7QUFBQTs7QUFBQSxtQkFDNEIsS0FBS1EsS0FEakM7QUFBQSxVQUNBOUMsS0FEQSxVQUNBQSxLQURBO0FBQUEsVUFDT0csTUFEUCxVQUNPQSxNQURQO0FBQUEsVUFDZTJCLFNBRGYsVUFDZUEsU0FEZjtBQUdQLFVBQU1pQyxtQkFBbUI7QUFDdkIvRCxvQkFEdUI7QUFFdkJHLHNCQUZ1QjtBQUd2Qk8sa0JBQVUsVUFIYTtBQUl2QnNELGdCQUFRbEMsVUFBVSxLQUFLaEMsS0FBZjtBQUplLE9BQXpCO0FBT0EsYUFBTywwQkFDTCxLQURLLEVBRUw7QUFDRW1FLGFBQUssY0FEUDtBQUVFQyxhQUFLO0FBQUEsaUJBQU0sT0FBS2pCLFdBQUwsR0FBbUJrQixDQUF6QjtBQUFBLFNBRlA7QUFHRUMsZUFBT0w7QUFIVCxPQUZLLEVBT0wsS0FBS2pCLEtBQUwsQ0FBV3VCLFFBUE4sQ0FBUDtBQVNEOzs7O0VBdEU2Q0MsZ0I7OztBQXlFaER6QixtQkFBbUIwQixXQUFuQixHQUFpQyxvQkFBakM7QUFDQTFCLG1CQUFtQm5ELFNBQW5CLEdBQStCQSxTQUEvQjtBQUNBbUQsbUJBQW1CSCxZQUFuQixHQUFrQ0EsWUFBbEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgY3JlYXRlRWxlbWVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IHtFdmVudE1hbmFnZXJ9IGZyb20gJ21qb2xuaXIuanMnO1xuaW1wb3J0IHtleHBlcmltZW50YWx9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuY29uc3Qge1ZpZXdwb3J0Q29udHJvbHMsIFRyYW5zaXRpb25NYW5hZ2VyfSA9IGV4cGVyaW1lbnRhbDtcblxuaW1wb3J0IENVUlNPUiBmcm9tICcuL3V0aWxzL2N1cnNvcnMnO1xuXG5jb25zdCBwcm9wVHlwZXMgPSB7XG4gIHZpZXdwb3J0U3RhdGU6IFByb3BUeXBlcy5mdW5jLFxuICBzdGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKiogVmlld3BvcnQgcHJvcHMgKi9cbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgbWFwLiAqL1xuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgbWFwLiAqL1xuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSBsb25naXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLiAqL1xuICBsb25naXR1ZGU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSBsYXRpdHVkZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBtYXAuICovXG4gIGxhdGl0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBUaGUgdGlsZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuICovXG4gIHpvb206IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFNwZWNpZnkgdGhlIGJlYXJpbmcgb2YgdGhlIHZpZXdwb3J0ICovXG4gIGJlYXJpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8qKiBTcGVjaWZ5IHRoZSBwaXRjaCBvZiB0aGUgdmlld3BvcnQgKi9cbiAgcGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8qKiBBbHRpdHVkZSBvZiB0aGUgdmlld3BvcnQgY2FtZXJhLiBEZWZhdWx0IDEuNSBcInNjcmVlbiBoZWlnaHRzXCIgKi9cbiAgLy8gTm90ZTogTm9uLXB1YmxpYyBBUEksIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9pc3N1ZXMvMTEzN1xuICBhbHRpdHVkZTogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gQ2FtZXJhIHBvc2l0aW9uIGZvciBGaXJzdFBlcnNvblZpZXdwb3J0XG4gIHBvc2l0aW9uOiBQcm9wVHlwZXMuYXJyYXksXG5cbiAgLyoqIFZpZXdwb3J0IGNvbnN0cmFpbnRzICovXG4gIC8vIE1heCB6b29tIGxldmVsXG4gIG1heFpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIE1pbiB6b29tIGxldmVsXG4gIG1pblpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIE1heCBwaXRjaCBpbiBkZWdyZWVzXG4gIG1heFBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBNaW4gcGl0Y2ggaW4gZGVncmVlc1xuICBtaW5QaXRjaDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogYG9uVmlld3BvcnRDaGFuZ2VgIGNhbGxiYWNrIGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoZVxuICAgKiBtYXAuIFRoZSBvYmplY3QgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBjb250YWlucyB2aWV3cG9ydCBwcm9wZXJ0aWVzXG4gICAqIHN1Y2ggYXMgYGxvbmdpdHVkZWAsIGBsYXRpdHVkZWAsIGB6b29tYCBldGMuXG4gICAqL1xuICBvblZpZXdwb3J0Q2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogVmlld3BvcnQgdHJhbnNpdGlvbiAqKi9cbiAgLy8gdHJhbnNpdGlvbiBkdXJhdGlvbiBmb3Igdmlld3BvcnQgY2hhbmdlXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gYW4gaW5zdGFuY2Ugb2YgVmlld3BvcnRUcmFuc2l0aW9uSW50ZXJwb2xhdG9yLCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGN1c3RvbSB0cmFuc2l0aW9ucy5cbiAgdHJhbnNpdGlvbkludGVycG9sYXRvcjogUHJvcFR5cGVzLm9iamVjdCxcbiAgLy8gdHlwZSBvZiBpbnRlcnJ1cHRpb24gb2YgY3VycmVudCB0cmFuc2l0aW9uIG9uIHVwZGF0ZS5cbiAgdHJhbnNpdGlvbkludGVycnVwdGlvbjogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gZWFzaW5nIGZ1bmN0aW9uXG4gIHRyYW5zaXRpb25FYXNpbmc6IFByb3BUeXBlcy5mdW5jLFxuICAvLyB0cmFuc2l0aW9uIHN0YXR1cyB1cGRhdGUgZnVuY3Rpb25zXG4gIG9uVHJhbnNpdGlvblN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25UcmFuc2l0aW9uSW50ZXJydXB0OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25UcmFuc2l0aW9uRW5kOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogRW5hYmxlcyBjb250cm9sIGV2ZW50IGhhbmRsaW5nICovXG4gIC8vIFNjcm9sbCB0byB6b29tXG4gIHNjcm9sbFpvb206IFByb3BUeXBlcy5ib29sLFxuICAvLyBEcmFnIHRvIHBhblxuICBkcmFnUGFuOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gRHJhZyB0byByb3RhdGVcbiAgZHJhZ1JvdGF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIERvdWJsZSBjbGljayB0byB6b29tXG4gIGRvdWJsZUNsaWNrWm9vbTogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIFBpbmNoIHRvIHpvb20gLyByb3RhdGVcbiAgdG91Y2hab29tUm90YXRlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKiogQWNjZXNzb3IgdGhhdCByZXR1cm5zIGEgY3Vyc29yIHN0eWxlIHRvIHNob3cgaW50ZXJhY3RpdmUgc3RhdGUgKi9cbiAgZ2V0Q3Vyc29yOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvLyBBIG1hcCBjb250cm9sIGluc3RhbmNlIHRvIHJlcGxhY2UgdGhlIGRlZmF1bHQgbWFwIGNvbnRyb2xzXG4gIC8vIFRoZSBvYmplY3QgbXVzdCBleHBvc2Ugb25lIHByb3BlcnR5OiBgZXZlbnRzYCBhcyBhbiBhcnJheSBvZiBzdWJzY3JpYmVkXG4gIC8vIGV2ZW50IG5hbWVzOyBhbmQgdHdvIG1ldGhvZHM6IGBzZXRTdGF0ZShzdGF0ZSlgIGFuZCBgaGFuZGxlKGV2ZW50KWBcbiAgY29udHJvbHM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZXZlbnRzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBoYW5kbGVFdmVudDogUHJvcFR5cGVzLmZ1bmNcbiAgfSlcbn07XG5cbmNvbnN0IGdldERlZmF1bHRDdXJzb3IgPSAoe2lzRHJhZ2dpbmd9KSA9PiAoaXNEcmFnZ2luZyA/IENVUlNPUi5HUkFCQklORyA6IENVUlNPUi5HUkFCKTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgVHJhbnNpdGlvbk1hbmFnZXIuZGVmYXVsdFByb3BzLCB7XG4gIG9uVmlld3BvcnRDaGFuZ2U6IG51bGwsXG5cbiAgc2Nyb2xsWm9vbTogdHJ1ZSxcbiAgZHJhZ1BhbjogdHJ1ZSxcbiAgZHJhZ1JvdGF0ZTogdHJ1ZSxcbiAgZG91YmxlQ2xpY2tab29tOiB0cnVlLFxuICB0b3VjaFpvb21Sb3RhdGU6IHRydWUsXG5cbiAgZ2V0Q3Vyc29yOiBnZXREZWZhdWx0Q3Vyc29yXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnRDb250cm9sbGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNEcmFnZ2luZzogZmFsc2UgLy8gV2hldGhlciB0aGUgY3Vyc29yIGlzIGRvd25cbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcih0aGlzLmV2ZW50Q2FudmFzKTtcblxuICAgIC8vIElmIHByb3BzLmNvbnRyb2xzIGlzIG5vdCBwcm92aWRlZCwgZmFsbGJhY2sgdG8gZGVmYXVsdCBNYXBDb250cm9scyBpbnN0YW5jZVxuICAgIC8vIENhbm5vdCB1c2UgZGVmYXVsdFByb3BzIGhlcmUgYmVjYXVzZSBpdCBuZWVkcyB0byBiZSBwZXIgbWFwIGluc3RhbmNlXG4gICAgdGhpcy5fY29udHJvbHMgPSB0aGlzLnByb3BzLmNvbnRyb2xzIHx8IG5ldyBWaWV3cG9ydENvbnRyb2xzKHRoaXMucHJvcHMudmlld3BvcnRTdGF0ZSk7XG5cbiAgICB0aGlzLl9jb250cm9scy5zZXRPcHRpb25zKFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICBvblN0YXRlQ2hhbmdlOiB0aGlzLl9vbkludGVyYWN0aXZlU3RhdGVDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgZXZlbnRNYW5hZ2VyOiB0aGlzLl9ldmVudE1hbmFnZXJcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuX3RyYW5zaXRpb25NYW5nZXIgPSBuZXcgVHJhbnNpdGlvbk1hbmFnZXIodGhpcy5wcm9wcyk7XG4gIH1cblxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNpdGlvbk1hbmdlcikge1xuICAgICAgY29uc3QgdHJhbnNpdGlvblRyaWdnZXJlZCA9IHRoaXMuX3RyYW5zaXRpb25NYW5nZXIucHJvY2Vzc1ZpZXdwb3J0Q2hhbmdlKG5leHRQcm9wcyk7XG4gICAgICAvLyBTa2lwIHRoaXMgcmVuZGVyIHRvIGF2b2lkIGp1bXAgZHVyaW5nIHZpZXdwb3J0IHRyYW5zaXRpb25zLlxuICAgICAgcmV0dXJuICF0cmFuc2l0aW9uVHJpZ2dlcmVkO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRyb2xzKSB7XG4gICAgICB0aGlzLl9jb250cm9scy5zZXRPcHRpb25zKG5leHRQcm9wcyk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIF9vbkludGVyYWN0aXZlU3RhdGVDaGFuZ2Uoe2lzRHJhZ2dpbmcgPSBmYWxzZX0pIHtcbiAgICBpZiAoaXNEcmFnZ2luZyAhPT0gdGhpcy5zdGF0ZS5pc0RyYWdnaW5nKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtpc0RyYWdnaW5nfSk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBnZXRDdXJzb3J9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGV2ZW50Q2FudmFzU3R5bGUgPSB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpcy5zdGF0ZSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnbWFwLWNvbnRyb2xzJyxcbiAgICAgICAgcmVmOiBjID0+ICh0aGlzLmV2ZW50Q2FudmFzID0gYyksXG4gICAgICAgIHN0eWxlOiBldmVudENhbnZhc1N0eWxlXG4gICAgICB9LFxuICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICk7XG4gIH1cbn1cblxuVmlld3BvcnRDb250cm9sbGVyLmRpc3BsYXlOYW1lID0gJ1ZpZXdwb3J0Q29udHJvbGxlcic7XG5WaWV3cG9ydENvbnRyb2xsZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuVmlld3BvcnRDb250cm9sbGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==